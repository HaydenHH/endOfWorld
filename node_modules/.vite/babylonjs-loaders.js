import {
  __commonJS,
  require_babylon
} from "./chunk-C2S6M2XJ.js";

// node_modules/babylonjs-loaders/babylonjs.loaders.min.js
var require_babylonjs_loaders_min = __commonJS({
  "node_modules/babylonjs-loaders/babylonjs.loaders.min.js"(exports, module) {
    !function(e, t) {
      typeof exports == "object" && typeof module == "object" ? module.exports = t(require_babylon()) : typeof define == "function" && define.amd ? define("babylonjs-loaders", ["babylonjs"], t) : typeof exports == "object" ? exports["babylonjs-loaders"] = t(require_babylon()) : e.LOADERS = t(e.BABYLON);
    }(typeof self != "undefined" ? self : typeof global != "undefined" ? global : exports, function(e) {
      return function(e2) {
        var t = {};
        function n(r) {
          if (t[r])
            return t[r].exports;
          var o = t[r] = { i: r, l: false, exports: {} };
          return e2[r].call(o.exports, o, o.exports, n), o.l = true, o.exports;
        }
        return n.m = e2, n.c = t, n.d = function(e3, t2, r) {
          n.o(e3, t2) || Object.defineProperty(e3, t2, { enumerable: true, get: r });
        }, n.r = function(e3) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, n.t = function(e3, t2) {
          if (1 & t2 && (e3 = n(e3)), 8 & t2)
            return e3;
          if (4 & t2 && typeof e3 == "object" && e3 && e3.__esModule)
            return e3;
          var r = Object.create(null);
          if (n.r(r), Object.defineProperty(r, "default", { enumerable: true, value: e3 }), 2 & t2 && typeof e3 != "string")
            for (var o in e3)
              n.d(r, o, function(t3) {
                return e3[t3];
              }.bind(null, o));
          return r;
        }, n.n = function(e3) {
          var t2 = e3 && e3.__esModule ? function() {
            return e3.default;
          } : function() {
            return e3;
          };
          return n.d(t2, "a", t2), t2;
        }, n.o = function(e3, t2) {
          return Object.prototype.hasOwnProperty.call(e3, t2);
        }, n.p = "", n(n.s = 20);
      }([function(t, n) {
        t.exports = e;
      }, function(e2, t, n) {
        "use strict";
        n.d(t, "a", function() {
          return a;
        }), n.d(t, "b", function() {
          return i;
        });
        var r = n(0), o = n(2), a = function() {
          function e3() {
          }
          return e3.Get = function(e4, t2, n2) {
            if (!t2 || n2 == null || !t2[n2])
              throw new Error(e4 + ": Failed to find index (" + n2 + ")");
            return t2[n2];
          }, e3.Assign = function(e4) {
            if (e4)
              for (var t2 = 0; t2 < e4.length; t2++)
                e4[t2].index = t2;
          }, e3;
        }(), i = function() {
          function e3(e4) {
            this._completePromises = new Array(), this._forAssetContainer = false, this._babylonLights = [], this._disableInstancedMesh = 0, this._disposed = false, this._state = null, this._extensions = new Array(), this._defaultBabylonMaterialData = {}, this._parent = e4;
          }
          return e3.RegisterExtension = function(t2, n2) {
            e3.UnregisterExtension(t2) && r.Logger.Warn("Extension with the name '" + t2 + "' already exists"), e3._RegisteredExtensions[t2] = { factory: n2 };
          }, e3.UnregisterExtension = function(t2) {
            return !!e3._RegisteredExtensions[t2] && (delete e3._RegisteredExtensions[t2], true);
          }, Object.defineProperty(e3.prototype, "state", { get: function() {
            return this._state;
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "gltf", { get: function() {
            return this._gltf;
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "bin", { get: function() {
            return this._bin;
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "parent", { get: function() {
            return this._parent;
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "babylonScene", { get: function() {
            return this._babylonScene;
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "rootBabylonMesh", { get: function() {
            return this._rootBabylonMesh;
          }, enumerable: false, configurable: true }), e3.prototype.dispose = function() {
            if (!this._disposed) {
              for (var e4 in this._disposed = true, this._completePromises.length = 0, this._extensions) {
                var t2 = this._extensions[e4];
                t2.dispose && t2.dispose(), delete this._extensions[e4];
              }
              this._gltf = null, this._babylonScene = null, this._rootBabylonMesh = null, this._parent.dispose();
            }
          }, e3.prototype.importMeshAsync = function(e4, t2, n2, r2, o2, a2, i2) {
            var s = this;
            return Promise.resolve().then(function() {
              s._babylonScene = t2, s._rootUrl = o2, s._fileName = i2 || "scene", s._forAssetContainer = n2, s._loadData(r2);
              var a3 = null;
              if (e4) {
                var l = {};
                if (s._gltf.nodes)
                  for (var u = 0, c = s._gltf.nodes; u < c.length; u++) {
                    var d = c[u];
                    d.name && (l[d.name] = d.index);
                  }
                a3 = (e4 instanceof Array ? e4 : [e4]).map(function(e5) {
                  var t3 = l[e5];
                  if (t3 === void 0)
                    throw new Error("Failed to find node '" + e5 + "'");
                  return t3;
                });
              }
              return s._loadAsync(a3, function() {
                return { meshes: s._getMeshes(), particleSystems: [], skeletons: s._getSkeletons(), animationGroups: s._getAnimationGroups(), lights: s._babylonLights, transformNodes: s._getTransformNodes(), geometries: s._getGeometries() };
              });
            });
          }, e3.prototype.loadAsync = function(e4, t2, n2, r2, o2) {
            var a2 = this;
            return Promise.resolve().then(function() {
              return a2._babylonScene = e4, a2._rootUrl = n2, a2._fileName = o2 || "scene", a2._loadData(t2), a2._loadAsync(null, function() {
              });
            });
          }, e3.prototype._loadAsync = function(e4, t2) {
            var n2 = this;
            return Promise.resolve().then(function() {
              n2._uniqueRootUrl = n2._rootUrl.indexOf("file:") === -1 && n2._fileName ? n2._rootUrl : "" + n2._rootUrl + Date.now() + "/", n2._loadExtensions(), n2._checkExtensions();
              var i2 = o.GLTFLoaderState[o.GLTFLoaderState.LOADING] + " => " + o.GLTFLoaderState[o.GLTFLoaderState.READY], s = o.GLTFLoaderState[o.GLTFLoaderState.LOADING] + " => " + o.GLTFLoaderState[o.GLTFLoaderState.COMPLETE];
              n2._parent._startPerformanceCounter(i2), n2._parent._startPerformanceCounter(s), n2._setState(o.GLTFLoaderState.LOADING), n2._extensionsOnLoading();
              var l = new Array(), u = n2._babylonScene.blockMaterialDirtyMechanism;
              if (n2._babylonScene.blockMaterialDirtyMechanism = true, e4)
                l.push(n2.loadSceneAsync("/nodes", { nodes: e4, index: -1 }));
              else if (n2._gltf.scene != null || n2._gltf.scenes && n2._gltf.scenes[0]) {
                var c = a.Get("/scene", n2._gltf.scenes, n2._gltf.scene || 0);
                l.push(n2.loadSceneAsync("/scenes/" + c.index, c));
              }
              if (n2.parent.loadAllMaterials && n2._gltf.materials)
                for (var d = 0; d < n2._gltf.materials.length; ++d) {
                  var f = n2._gltf.materials[d], h = "/materials/" + d, p = r.Material.TriangleFillMode;
                  l.push(n2._loadMaterialAsync(h, f, null, p, function(e5) {
                  }));
                }
              n2._babylonScene.blockMaterialDirtyMechanism = u, n2._parent.compileMaterials && l.push(n2._compileMaterialsAsync()), n2._parent.compileShadowGenerators && l.push(n2._compileShadowGeneratorsAsync());
              var _ = Promise.all(l).then(function() {
                return n2._rootBabylonMesh && n2._rootBabylonMesh.setEnabled(true), n2._extensionsOnReady(), n2._setState(o.GLTFLoaderState.READY), n2._startAnimations(), t2();
              });
              return _.then(function() {
                n2._parent._endPerformanceCounter(i2), r.Tools.SetImmediate(function() {
                  n2._disposed || Promise.all(n2._completePromises).then(function() {
                    n2._parent._endPerformanceCounter(s), n2._setState(o.GLTFLoaderState.COMPLETE), n2._parent.onCompleteObservable.notifyObservers(void 0), n2._parent.onCompleteObservable.clear(), n2.dispose();
                  }, function(e5) {
                    n2._parent.onErrorObservable.notifyObservers(e5), n2._parent.onErrorObservable.clear(), n2.dispose();
                  });
                });
              }), _;
            }).catch(function(e5) {
              throw n2._disposed || (n2._parent.onErrorObservable.notifyObservers(e5), n2._parent.onErrorObservable.clear(), n2.dispose()), e5;
            });
          }, e3.prototype._loadData = function(e4) {
            if (this._gltf = e4.json, this._setupData(), e4.bin) {
              var t2 = this._gltf.buffers;
              if (t2 && t2[0] && !t2[0].uri) {
                var n2 = t2[0];
                (n2.byteLength < e4.bin.byteLength - 3 || n2.byteLength > e4.bin.byteLength) && r.Logger.Warn("Binary buffer length (" + n2.byteLength + ") from JSON does not match chunk length (" + e4.bin.byteLength + ")"), this._bin = e4.bin;
              } else
                r.Logger.Warn("Unexpected BIN chunk");
            }
          }, e3.prototype._setupData = function() {
            if (a.Assign(this._gltf.accessors), a.Assign(this._gltf.animations), a.Assign(this._gltf.buffers), a.Assign(this._gltf.bufferViews), a.Assign(this._gltf.cameras), a.Assign(this._gltf.images), a.Assign(this._gltf.materials), a.Assign(this._gltf.meshes), a.Assign(this._gltf.nodes), a.Assign(this._gltf.samplers), a.Assign(this._gltf.scenes), a.Assign(this._gltf.skins), a.Assign(this._gltf.textures), this._gltf.nodes) {
              for (var e4 = {}, t2 = 0, n2 = this._gltf.nodes; t2 < n2.length; t2++) {
                if ((u = n2[t2]).children)
                  for (var r2 = 0, o2 = u.children; r2 < o2.length; r2++) {
                    e4[o2[r2]] = u.index;
                  }
              }
              for (var i2 = this._createRootNode(), s = 0, l = this._gltf.nodes; s < l.length; s++) {
                var u, c = e4[(u = l[s]).index];
                u.parent = c === void 0 ? i2 : this._gltf.nodes[c];
              }
            }
          }, e3.prototype._loadExtensions = function() {
            for (var t2 in e3._RegisteredExtensions) {
              var n2 = e3._RegisteredExtensions[t2].factory(this);
              n2.name !== t2 && r.Logger.Warn("The name of the glTF loader extension instance does not match the registered name: " + n2.name + " !== " + t2), this._extensions.push(n2), this._parent.onExtensionLoadedObservable.notifyObservers(n2);
            }
            this._extensions.sort(function(e4, t3) {
              return (e4.order || Number.MAX_VALUE) - (t3.order || Number.MAX_VALUE);
            }), this._parent.onExtensionLoadedObservable.clear();
          }, e3.prototype._checkExtensions = function() {
            if (this._gltf.extensionsRequired)
              for (var e4 = function(e5) {
                if (!t2._extensions.some(function(t3) {
                  return t3.name === e5 && t3.enabled;
                }))
                  throw new Error("Require extension " + e5 + " is not available");
              }, t2 = this, n2 = 0, r2 = this._gltf.extensionsRequired; n2 < r2.length; n2++) {
                e4(r2[n2]);
              }
          }, e3.prototype._setState = function(e4) {
            this._state = e4, this.log(o.GLTFLoaderState[this._state]);
          }, e3.prototype._createRootNode = function() {
            this._babylonScene._blockEntityCollection = this._forAssetContainer, this._rootBabylonMesh = new r.Mesh("__root__", this._babylonScene), this._babylonScene._blockEntityCollection = false, this._rootBabylonMesh.setEnabled(false);
            var t2 = { _babylonTransformNode: this._rootBabylonMesh, index: -1 };
            switch (this._parent.coordinateSystemMode) {
              case o.GLTFLoaderCoordinateSystemMode.AUTO:
                this._babylonScene.useRightHandedSystem || (t2.rotation = [0, 1, 0, 0], t2.scale = [1, 1, -1], e3._LoadTransform(t2, this._rootBabylonMesh));
                break;
              case o.GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED:
                this._babylonScene.useRightHandedSystem = true;
                break;
              default:
                throw new Error("Invalid coordinate system mode (" + this._parent.coordinateSystemMode + ")");
            }
            return this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh), t2;
          }, e3.prototype.loadSceneAsync = function(e4, t2) {
            var n2 = this, r2 = this._extensionsLoadSceneAsync(e4, t2);
            if (r2)
              return r2;
            var o2 = new Array();
            if (this.logOpen(e4 + " " + (t2.name || "")), t2.nodes)
              for (var i2 = 0, s = t2.nodes; i2 < s.length; i2++) {
                var l = s[i2], u = a.Get(e4 + "/nodes/" + l, this._gltf.nodes, l);
                o2.push(this.loadNodeAsync("/nodes/" + u.index, u, function(e5) {
                  e5.parent = n2._rootBabylonMesh;
                }));
              }
            if (this._gltf.nodes)
              for (var c = 0, d = this._gltf.nodes; c < d.length; c++) {
                if ((u = d[c])._babylonTransformNode && u._babylonBones)
                  for (var f = 0, h = u._babylonBones; f < h.length; f++) {
                    h[f].linkTransformNode(u._babylonTransformNode);
                  }
              }
            return o2.push(this._loadAnimationsAsync()), this.logClose(), Promise.all(o2).then(function() {
            });
          }, e3.prototype._forEachPrimitive = function(e4, t2) {
            if (e4._primitiveBabylonMeshes)
              for (var n2 = 0, r2 = e4._primitiveBabylonMeshes; n2 < r2.length; n2++) {
                t2(r2[n2]);
              }
          }, e3.prototype._getGeometries = function() {
            var e4 = new Array(), t2 = this._gltf.nodes;
            if (t2)
              for (var n2 = 0, r2 = t2; n2 < r2.length; n2++) {
                var o2 = r2[n2];
                this._forEachPrimitive(o2, function(t3) {
                  var n3 = t3.geometry;
                  n3 && e4.indexOf(n3) === -1 && e4.push(n3);
                });
              }
            return e4;
          }, e3.prototype._getMeshes = function() {
            var e4 = new Array();
            e4.push(this._rootBabylonMesh);
            var t2 = this._gltf.nodes;
            if (t2)
              for (var n2 = 0, r2 = t2; n2 < r2.length; n2++) {
                var o2 = r2[n2];
                this._forEachPrimitive(o2, function(t3) {
                  e4.push(t3);
                });
              }
            return e4;
          }, e3.prototype._getTransformNodes = function() {
            var e4 = new Array(), t2 = this._gltf.nodes;
            if (t2)
              for (var n2 = 0, r2 = t2; n2 < r2.length; n2++) {
                var o2 = r2[n2];
                o2._babylonTransformNode && o2._babylonTransformNode.getClassName() === "TransformNode" && e4.push(o2._babylonTransformNode);
              }
            return e4;
          }, e3.prototype._getSkeletons = function() {
            var e4 = new Array(), t2 = this._gltf.skins;
            if (t2)
              for (var n2 = 0, r2 = t2; n2 < r2.length; n2++) {
                var o2 = r2[n2];
                o2._data && e4.push(o2._data.babylonSkeleton);
              }
            return e4;
          }, e3.prototype._getAnimationGroups = function() {
            var e4 = new Array(), t2 = this._gltf.animations;
            if (t2)
              for (var n2 = 0, r2 = t2; n2 < r2.length; n2++) {
                var o2 = r2[n2];
                o2._babylonAnimationGroup && e4.push(o2._babylonAnimationGroup);
              }
            return e4;
          }, e3.prototype._startAnimations = function() {
            switch (this._parent.animationStartMode) {
              case o.GLTFLoaderAnimationStartMode.NONE:
                break;
              case o.GLTFLoaderAnimationStartMode.FIRST:
                (e4 = this._getAnimationGroups()).length !== 0 && e4[0].start(true);
                break;
              case o.GLTFLoaderAnimationStartMode.ALL:
                for (var e4, t2 = 0, n2 = e4 = this._getAnimationGroups(); t2 < n2.length; t2++) {
                  n2[t2].start(true);
                }
                break;
              default:
                return void r.Logger.Error("Invalid animation start mode (" + this._parent.animationStartMode + ")");
            }
          }, e3.prototype.loadNodeAsync = function(t2, n2, o2) {
            var i2 = this;
            o2 === void 0 && (o2 = function() {
            });
            var s = this._extensionsLoadNodeAsync(t2, n2, o2);
            if (s)
              return s;
            if (n2._babylonTransformNode)
              throw new Error(t2 + ": Invalid recursive node hierarchy");
            var l = new Array();
            this.logOpen(t2 + " " + (n2.name || ""));
            var u = function(r2) {
              if (e3.AddPointerMetadata(r2, t2), e3._LoadTransform(n2, r2), n2.camera != null) {
                var s2 = a.Get(t2 + "/camera", i2._gltf.cameras, n2.camera);
                l.push(i2.loadCameraAsync("/cameras/" + s2.index, s2, function(e4) {
                  e4.parent = r2;
                }));
              }
              if (n2.children)
                for (var u2 = 0, c2 = n2.children; u2 < c2.length; u2++) {
                  var d2 = c2[u2], f = a.Get(t2 + "/children/" + d2, i2._gltf.nodes, d2);
                  l.push(i2.loadNodeAsync("/nodes/" + f.index, f, function(e4) {
                    e4.parent = r2;
                  }));
                }
              o2(r2);
            };
            if (n2.mesh == null) {
              var c = n2.name || "node" + n2.index;
              this._babylonScene._blockEntityCollection = this._forAssetContainer, n2._babylonTransformNode = new r.TransformNode(c, this._babylonScene), this._babylonScene._blockEntityCollection = false, u(n2._babylonTransformNode);
            } else {
              var d = a.Get(t2 + "/mesh", this._gltf.meshes, n2.mesh);
              l.push(this._loadMeshAsync("/meshes/" + d.index, n2, d, u));
            }
            return this.logClose(), Promise.all(l).then(function() {
              return i2._forEachPrimitive(n2, function(e4) {
                e4.geometry && e4.geometry.useBoundingInfoFromGeometry ? e4._updateBoundingInfo() : e4.refreshBoundingInfo(true);
              }), n2._babylonTransformNode;
            });
          }, e3.prototype._loadMeshAsync = function(e4, t2, n2, o2) {
            var i2 = n2.primitives;
            if (!i2 || !i2.length)
              throw new Error(e4 + ": Primitives are missing");
            i2[0].index == null && a.Assign(i2);
            var s = new Array();
            this.logOpen(e4 + " " + (n2.name || ""));
            var l = t2.name || "node" + t2.index;
            if (i2.length === 1) {
              var u = n2.primitives[0];
              s.push(this._loadMeshPrimitiveAsync(e4 + "/primitives/" + u.index, l, t2, n2, u, function(e5) {
                t2._babylonTransformNode = e5, t2._primitiveBabylonMeshes = [e5];
              }));
            } else {
              this._babylonScene._blockEntityCollection = this._forAssetContainer, t2._babylonTransformNode = new r.TransformNode(l, this._babylonScene), this._babylonScene._blockEntityCollection = false, t2._primitiveBabylonMeshes = [];
              for (var c = 0, d = i2; c < d.length; c++) {
                u = d[c];
                s.push(this._loadMeshPrimitiveAsync(e4 + "/primitives/" + u.index, l + "_primitive" + u.index, t2, n2, u, function(e5) {
                  e5.parent = t2._babylonTransformNode, t2._primitiveBabylonMeshes.push(e5);
                }));
              }
            }
            if (t2.skin != null) {
              var f = a.Get(e4 + "/skin", this._gltf.skins, t2.skin);
              s.push(this._loadSkinAsync("/skins/" + f.index, t2, f));
            }
            return o2(t2._babylonTransformNode), this.logClose(), Promise.all(s).then(function() {
              return t2._babylonTransformNode;
            });
          }, e3.prototype._loadMeshPrimitiveAsync = function(t2, n2, o2, i2, s, l) {
            var u = this, c = this._extensionsLoadMeshPrimitiveAsync(t2, n2, o2, i2, s, l);
            if (c)
              return c;
            this.logOpen("" + t2);
            var d, f, h = this._disableInstancedMesh === 0 && this._parent.createInstances && o2.skin == null && !i2.primitives[0].targets;
            if (h && s._instanceData)
              d = s._instanceData.babylonSourceMesh.createInstance(n2), f = s._instanceData.promise;
            else {
              var p = new Array();
              this._babylonScene._blockEntityCollection = this._forAssetContainer;
              var _ = new r.Mesh(n2, this._babylonScene);
              this._babylonScene._blockEntityCollection = false, _.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? r.Material.CounterClockWiseSideOrientation : r.Material.ClockWiseSideOrientation, this._createMorphTargets(t2, o2, i2, s, _), p.push(this._loadVertexDataAsync(t2, s, _).then(function(e4) {
                return u._loadMorphTargetsAsync(t2, s, _, e4).then(function() {
                  u._babylonScene._blockEntityCollection = u._forAssetContainer, e4.applyToMesh(_), u._babylonScene._blockEntityCollection = false;
                });
              }));
              var m = e3._GetDrawMode(t2, s.mode);
              if (s.material == null) {
                var y = this._defaultBabylonMaterialData[m];
                y || (y = this._createDefaultMaterial("__GLTFLoader._default", m), this._parent.onMaterialLoadedObservable.notifyObservers(y), this._defaultBabylonMaterialData[m] = y), _.material = y;
              } else {
                var b = a.Get(t2 + "/material", this._gltf.materials, s.material);
                p.push(this._loadMaterialAsync("/materials/" + b.index, b, _, m, function(e4) {
                  _.material = e4;
                }));
              }
              f = Promise.all(p), h && (s._instanceData = { babylonSourceMesh: _, promise: f }), d = _;
            }
            return e3.AddPointerMetadata(d, t2), this._parent.onMeshLoadedObservable.notifyObservers(d), l(d), this.logClose(), f.then(function() {
              return d;
            });
          }, e3.prototype._loadVertexDataAsync = function(e4, t2, n2) {
            var o2 = this, i2 = this._extensionsLoadVertexDataAsync(e4, t2, n2);
            if (i2)
              return i2;
            var s = t2.attributes;
            if (!s)
              throw new Error(e4 + ": Attributes are missing");
            var l = new Array(), u = new r.Geometry(n2.name, this._babylonScene);
            if (t2.indices == null)
              n2.isUnIndexed = true;
            else {
              var c = a.Get(e4 + "/indices", this._gltf.accessors, t2.indices);
              l.push(this._loadIndicesAccessorAsync("/accessors/" + c.index, c).then(function(e5) {
                u.setIndices(e5);
              }));
            }
            var d = function(t3, i3, c2) {
              if (s[t3] != null) {
                n2._delayInfo = n2._delayInfo || [], n2._delayInfo.indexOf(i3) === -1 && n2._delayInfo.push(i3);
                var d2 = a.Get(e4 + "/attributes/" + t3, o2._gltf.accessors, s[t3]);
                l.push(o2._loadVertexAccessorAsync("/accessors/" + d2.index, d2, i3).then(function(e5) {
                  if (e5.getKind() === r.VertexBuffer.PositionKind && !o2.parent.alwaysComputeBoundingBox && !n2.skeleton) {
                    var t4 = d2.min, a2 = d2.max;
                    if (t4 !== void 0 && a2 !== void 0) {
                      var i4 = r.TmpVectors.Vector3[0], s2 = r.TmpVectors.Vector3[1];
                      i4.copyFromFloats.apply(i4, t4), s2.copyFromFloats.apply(s2, a2), u._boundingInfo = new r.BoundingInfo(i4, s2), u.useBoundingInfoFromGeometry = true;
                    }
                  }
                  u.setVerticesBuffer(e5, d2.count);
                })), i3 == r.VertexBuffer.MatricesIndicesExtraKind && (n2.numBoneInfluencers = 8), c2 && c2(d2);
              }
            };
            return d("POSITION", r.VertexBuffer.PositionKind), d("NORMAL", r.VertexBuffer.NormalKind), d("TANGENT", r.VertexBuffer.TangentKind), d("TEXCOORD_0", r.VertexBuffer.UVKind), d("TEXCOORD_1", r.VertexBuffer.UV2Kind), d("JOINTS_0", r.VertexBuffer.MatricesIndicesKind), d("WEIGHTS_0", r.VertexBuffer.MatricesWeightsKind), d("JOINTS_1", r.VertexBuffer.MatricesIndicesExtraKind), d("WEIGHTS_1", r.VertexBuffer.MatricesWeightsExtraKind), d("COLOR_0", r.VertexBuffer.ColorKind, function(e5) {
              e5.type === "VEC4" && (n2.hasVertexAlpha = true);
            }), Promise.all(l).then(function() {
              return u;
            });
          }, e3.prototype._createMorphTargets = function(e4, t2, n2, o2, a2) {
            if (o2.targets) {
              if (t2._numMorphTargets == null)
                t2._numMorphTargets = o2.targets.length;
              else if (o2.targets.length !== t2._numMorphTargets)
                throw new Error(e4 + ": Primitives do not have the same number of targets");
              var i2 = n2.extras ? n2.extras.targetNames : null;
              a2.morphTargetManager = new r.MorphTargetManager(a2.getScene());
              for (var s = 0; s < o2.targets.length; s++) {
                var l = t2.weights ? t2.weights[s] : n2.weights ? n2.weights[s] : 0, u = i2 ? i2[s] : "morphTarget" + s;
                a2.morphTargetManager.addTarget(new r.MorphTarget(u, l, a2.getScene()));
              }
            }
          }, e3.prototype._loadMorphTargetsAsync = function(e4, t2, n2, r2) {
            if (!t2.targets)
              return Promise.resolve();
            for (var o2 = new Array(), a2 = n2.morphTargetManager, i2 = 0; i2 < a2.numTargets; i2++) {
              var s = a2.getTarget(i2);
              o2.push(this._loadMorphTargetVertexDataAsync(e4 + "/targets/" + i2, r2, t2.targets[i2], s));
            }
            return Promise.all(o2).then(function() {
            });
          }, e3.prototype._loadMorphTargetVertexDataAsync = function(e4, t2, n2, o2) {
            var i2 = this, s = new Array(), l = function(r2, o3, l2) {
              if (n2[r2] != null) {
                var u = t2.getVertexBuffer(o3);
                if (u) {
                  var c = a.Get(e4 + "/" + r2, i2._gltf.accessors, n2[r2]);
                  s.push(i2._loadFloatAccessorAsync("/accessors/" + c.index, c).then(function(e5) {
                    l2(u, e5);
                  }));
                }
              }
            };
            return l("POSITION", r.VertexBuffer.PositionKind, function(e5, t3) {
              var n3 = new Float32Array(t3.length);
              e5.forEach(t3.length, function(e6, r2) {
                n3[r2] = t3[r2] + e6;
              }), o2.setPositions(n3);
            }), l("NORMAL", r.VertexBuffer.NormalKind, function(e5, t3) {
              var n3 = new Float32Array(t3.length);
              e5.forEach(n3.length, function(e6, r2) {
                n3[r2] = t3[r2] + e6;
              }), o2.setNormals(n3);
            }), l("TANGENT", r.VertexBuffer.TangentKind, function(e5, t3) {
              var n3 = new Float32Array(t3.length / 3 * 4), r2 = 0;
              e5.forEach(t3.length / 3 * 4, function(e6, o3) {
                (o3 + 1) % 4 != 0 && (n3[r2] = t3[r2] + e6, r2++);
              }), o2.setTangents(n3);
            }), Promise.all(s).then(function() {
            });
          }, e3._LoadTransform = function(e4, t2) {
            if (e4.skin == null) {
              var n2 = r.Vector3.Zero(), o2 = r.Quaternion.Identity(), a2 = r.Vector3.One();
              if (e4.matrix)
                r.Matrix.FromArray(e4.matrix).decompose(a2, o2, n2);
              else
                e4.translation && (n2 = r.Vector3.FromArray(e4.translation)), e4.rotation && (o2 = r.Quaternion.FromArray(e4.rotation)), e4.scale && (a2 = r.Vector3.FromArray(e4.scale));
              t2.position = n2, t2.rotationQuaternion = o2, t2.scaling = a2;
            }
          }, e3.prototype._loadSkinAsync = function(e4, t2, n2) {
            var o2 = this, a2 = this._extensionsLoadSkinAsync(e4, t2, n2);
            if (a2)
              return a2;
            var i2 = function(e5) {
              o2._forEachPrimitive(t2, function(t3) {
                t3.skeleton = e5;
              });
            };
            if (n2._data)
              return i2(n2._data.babylonSkeleton), n2._data.promise;
            var s = "skeleton" + n2.index;
            this._babylonScene._blockEntityCollection = this._forAssetContainer;
            var l = new r.Skeleton(n2.name || s, s, this._babylonScene);
            this._babylonScene._blockEntityCollection = false, l.overrideMesh = this._rootBabylonMesh, this._loadBones(e4, n2, l), i2(l);
            var u = this._loadSkinInverseBindMatricesDataAsync(e4, n2).then(function(e5) {
              o2._updateBoneMatrices(l, e5);
            });
            return n2._data = { babylonSkeleton: l, promise: u }, u;
          }, e3.prototype._loadBones = function(e4, t2, n2) {
            for (var r2 = {}, o2 = 0, i2 = t2.joints; o2 < i2.length; o2++) {
              var s = i2[o2], l = a.Get(e4 + "/joints/" + s, this._gltf.nodes, s);
              this._loadBone(l, t2, n2, r2);
            }
          }, e3.prototype._loadBone = function(e4, t2, n2, o2) {
            var a2 = o2[e4.index];
            if (a2)
              return a2;
            var i2 = null;
            e4.parent && e4.parent._babylonTransformNode !== this._rootBabylonMesh && (i2 = this._loadBone(e4.parent, t2, n2, o2));
            var s = t2.joints.indexOf(e4.index);
            return a2 = new r.Bone(e4.name || "joint" + e4.index, n2, i2, this._getNodeMatrix(e4), null, null, s), o2[e4.index] = a2, e4._babylonBones = e4._babylonBones || [], e4._babylonBones.push(a2), a2;
          }, e3.prototype._loadSkinInverseBindMatricesDataAsync = function(e4, t2) {
            if (t2.inverseBindMatrices == null)
              return Promise.resolve(null);
            var n2 = a.Get(e4 + "/inverseBindMatrices", this._gltf.accessors, t2.inverseBindMatrices);
            return this._loadFloatAccessorAsync("/accessors/" + n2.index, n2);
          }, e3.prototype._updateBoneMatrices = function(e4, t2) {
            for (var n2 = 0, o2 = e4.bones; n2 < o2.length; n2++) {
              var a2 = o2[n2], i2 = r.Matrix.Identity(), s = a2._index;
              t2 && s !== -1 && (r.Matrix.FromArrayToRef(t2, 16 * s, i2), i2.invertToRef(i2));
              var l = a2.getParent();
              l && i2.multiplyToRef(l.getInvertedAbsoluteTransform(), i2), a2.setBindPose(i2), a2.updateMatrix(i2, false, false), a2._updateDifferenceMatrix(void 0, false);
            }
          }, e3.prototype._getNodeMatrix = function(e4) {
            return e4.matrix ? r.Matrix.FromArray(e4.matrix) : r.Matrix.Compose(e4.scale ? r.Vector3.FromArray(e4.scale) : r.Vector3.One(), e4.rotation ? r.Quaternion.FromArray(e4.rotation) : r.Quaternion.Identity(), e4.translation ? r.Vector3.FromArray(e4.translation) : r.Vector3.Zero());
          }, e3.prototype.loadCameraAsync = function(t2, n2, o2) {
            o2 === void 0 && (o2 = function() {
            });
            var a2 = this._extensionsLoadCameraAsync(t2, n2, o2);
            if (a2)
              return a2;
            var i2 = new Array();
            this.logOpen(t2 + " " + (n2.name || "")), this._babylonScene._blockEntityCollection = this._forAssetContainer;
            var s = new r.FreeCamera(n2.name || "camera" + n2.index, r.Vector3.Zero(), this._babylonScene, false);
            switch (this._babylonScene._blockEntityCollection = false, s.ignoreParentScaling = true, s.rotation = new r.Vector3(0, Math.PI, 0), n2.type) {
              case "perspective":
                var l = n2.perspective;
                if (!l)
                  throw new Error(t2 + ": Camera perspective properties are missing");
                s.fov = l.yfov, s.minZ = l.znear, s.maxZ = l.zfar || Number.MAX_VALUE;
                break;
              case "orthographic":
                if (!n2.orthographic)
                  throw new Error(t2 + ": Camera orthographic properties are missing");
                s.mode = r.Camera.ORTHOGRAPHIC_CAMERA, s.orthoLeft = -n2.orthographic.xmag, s.orthoRight = n2.orthographic.xmag, s.orthoBottom = -n2.orthographic.ymag, s.orthoTop = n2.orthographic.ymag, s.minZ = n2.orthographic.znear, s.maxZ = n2.orthographic.zfar;
                break;
              default:
                throw new Error(t2 + ": Invalid camera type (" + n2.type + ")");
            }
            return e3.AddPointerMetadata(s, t2), this._parent.onCameraLoadedObservable.notifyObservers(s), o2(s), this.logClose(), Promise.all(i2).then(function() {
              return s;
            });
          }, e3.prototype._loadAnimationsAsync = function() {
            var e4 = this._gltf.animations;
            if (!e4)
              return Promise.resolve();
            for (var t2 = new Array(), n2 = 0; n2 < e4.length; n2++) {
              var r2 = e4[n2];
              t2.push(this.loadAnimationAsync("/animations/" + r2.index, r2));
            }
            return Promise.all(t2).then(function() {
            });
          }, e3.prototype.loadAnimationAsync = function(e4, t2) {
            var n2 = this._extensionsLoadAnimationAsync(e4, t2);
            if (n2)
              return n2;
            this._babylonScene._blockEntityCollection = this._forAssetContainer;
            var o2 = new r.AnimationGroup(t2.name || "animation" + t2.index, this._babylonScene);
            this._babylonScene._blockEntityCollection = false, t2._babylonAnimationGroup = o2;
            var i2 = new Array();
            a.Assign(t2.channels), a.Assign(t2.samplers);
            for (var s = 0, l = t2.channels; s < l.length; s++) {
              var u = l[s];
              i2.push(this._loadAnimationChannelAsync(e4 + "/channels/" + u.index, e4, t2, u, o2));
            }
            return Promise.all(i2).then(function() {
              return o2.normalize(0), o2;
            });
          }, e3.prototype._loadAnimationChannelAsync = function(e4, t2, n2, o2, i2, s) {
            var l = this;
            if (s === void 0 && (s = null), o2.target.node == null)
              return Promise.resolve();
            var u = a.Get(e4 + "/target/node", this._gltf.nodes, o2.target.node);
            if (o2.target.path === "weights" && !u._numMorphTargets || o2.target.path !== "weights" && !u._babylonTransformNode)
              return Promise.resolve();
            var c = a.Get(e4 + "/sampler", n2.samplers, o2.sampler);
            return this._loadAnimationSamplerAsync(t2 + "/samplers/" + o2.sampler, c).then(function(t3) {
              var n3, a2;
              switch (o2.target.path) {
                case "translation":
                  n3 = "position", a2 = r.Animation.ANIMATIONTYPE_VECTOR3;
                  break;
                case "rotation":
                  n3 = "rotationQuaternion", a2 = r.Animation.ANIMATIONTYPE_QUATERNION;
                  break;
                case "scale":
                  n3 = "scaling", a2 = r.Animation.ANIMATIONTYPE_VECTOR3;
                  break;
                case "weights":
                  n3 = "influence", a2 = r.Animation.ANIMATIONTYPE_FLOAT;
                  break;
                default:
                  throw new Error(e4 + "/target/path: Invalid value (" + o2.target.path + ")");
              }
              var c2, d, f = 0;
              switch (n3) {
                case "position":
                  c2 = function() {
                    var e5 = r.Vector3.FromArray(t3.output, f);
                    return f += 3, e5;
                  };
                  break;
                case "rotationQuaternion":
                  c2 = function() {
                    var e5 = r.Quaternion.FromArray(t3.output, f);
                    return f += 4, e5;
                  };
                  break;
                case "scaling":
                  c2 = function() {
                    var e5 = r.Vector3.FromArray(t3.output, f);
                    return f += 3, e5;
                  };
                  break;
                case "influence":
                  c2 = function() {
                    for (var e5 = new Array(u._numMorphTargets), n4 = 0; n4 < u._numMorphTargets; n4++)
                      e5[n4] = t3.output[f++];
                    return e5;
                  };
              }
              switch (t3.interpolation) {
                case "STEP":
                  d = function(e5) {
                    return { frame: t3.input[e5], value: c2(), interpolation: r.AnimationKeyInterpolation.STEP };
                  };
                  break;
                case "LINEAR":
                  d = function(e5) {
                    return { frame: t3.input[e5], value: c2() };
                  };
                  break;
                case "CUBICSPLINE":
                  d = function(e5) {
                    return { frame: t3.input[e5], inTangent: c2(), value: c2(), outTangent: c2() };
                  };
              }
              for (var h = new Array(t3.input.length), p = 0; p < t3.input.length; p++)
                h[p] = d(p);
              if (n3 === "influence")
                for (var _ = function(e5) {
                  var t4 = i2.name + "_channel" + i2.targetedAnimations.length, o3 = new r.Animation(t4, n3, 1, a2);
                  o3.setKeys(h.map(function(t5) {
                    return { frame: t5.frame, inTangent: t5.inTangent ? t5.inTangent[e5] : void 0, value: t5.value[e5], outTangent: t5.outTangent ? t5.outTangent[e5] : void 0 };
                  })), l._forEachPrimitive(u, function(t5) {
                    var n4 = t5.morphTargetManager.getTarget(e5), r2 = o3.clone();
                    n4.animations.push(r2), i2.addTargetedAnimation(r2, n4);
                  });
                }, m = 0; m < u._numMorphTargets; m++)
                  _(m);
              else {
                var y = i2.name + "_channel" + i2.targetedAnimations.length, b = new r.Animation(y, n3, 1, a2);
                b.setKeys(h), s != null && s.animations != null ? (s.animations.push(b), i2.addTargetedAnimation(b, s)) : (u._babylonTransformNode.animations.push(b), i2.addTargetedAnimation(b, u._babylonTransformNode));
              }
            });
          }, e3.prototype._loadAnimationSamplerAsync = function(e4, t2) {
            if (t2._data)
              return t2._data;
            var n2 = t2.interpolation || "LINEAR";
            switch (n2) {
              case "STEP":
              case "LINEAR":
              case "CUBICSPLINE":
                break;
              default:
                throw new Error(e4 + "/interpolation: Invalid value (" + t2.interpolation + ")");
            }
            var r2 = a.Get(e4 + "/input", this._gltf.accessors, t2.input), o2 = a.Get(e4 + "/output", this._gltf.accessors, t2.output);
            return t2._data = Promise.all([this._loadFloatAccessorAsync("/accessors/" + r2.index, r2), this._loadFloatAccessorAsync("/accessors/" + o2.index, o2)]).then(function(e5) {
              var t3 = e5[0], r3 = e5[1];
              return { input: t3, interpolation: n2, output: r3 };
            }), t2._data;
          }, e3.prototype._loadBufferAsync = function(e4, t2, n2, r2) {
            var o2 = this._extensionsLoadBufferAsync(e4, t2, n2, r2);
            if (o2)
              return o2;
            if (!t2._data)
              if (t2.uri)
                t2._data = this.loadUriAsync(e4 + "/uri", t2, t2.uri);
              else {
                if (!this._bin)
                  throw new Error(e4 + ": Uri is missing or the binary glTF is missing its binary chunk");
                t2._data = this._bin.readAsync(0, t2.byteLength);
              }
            return t2._data.then(function(t3) {
              try {
                return new Uint8Array(t3.buffer, t3.byteOffset + n2, r2);
              } catch (t4) {
                throw new Error(e4 + ": " + t4.message);
              }
            });
          }, e3.prototype.loadBufferViewAsync = function(e4, t2) {
            var n2 = this._extensionsLoadBufferViewAsync(e4, t2);
            if (n2)
              return n2;
            if (t2._data)
              return t2._data;
            var r2 = a.Get(e4 + "/buffer", this._gltf.buffers, t2.buffer);
            return t2._data = this._loadBufferAsync("/buffers/" + r2.index, r2, t2.byteOffset || 0, t2.byteLength), t2._data;
          }, e3.prototype._loadAccessorAsync = function(t2, n2, o2) {
            var i2 = this;
            if (n2._data)
              return n2._data;
            var s = e3._GetNumComponents(t2, n2.type), l = s * r.VertexBuffer.GetTypeByteLength(n2.componentType), u = s * n2.count;
            if (n2.bufferView == null)
              n2._data = Promise.resolve(new o2(u));
            else {
              var c = a.Get(t2 + "/bufferView", this._gltf.bufferViews, n2.bufferView);
              n2._data = this.loadBufferViewAsync("/bufferViews/" + c.index, c).then(function(a2) {
                if (n2.componentType !== 5126 || n2.normalized || c.byteStride && c.byteStride !== l) {
                  var i3 = new o2(u);
                  return r.VertexBuffer.ForEach(a2, n2.byteOffset || 0, c.byteStride || l, s, n2.componentType, i3.length, n2.normalized || false, function(e4, t3) {
                    i3[t3] = e4;
                  }), i3;
                }
                return e3._GetTypedArray(t2, n2.componentType, a2, n2.byteOffset, u);
              });
            }
            if (n2.sparse) {
              var d = n2.sparse;
              n2._data = n2._data.then(function(u2) {
                var c2 = u2, f = a.Get(t2 + "/sparse/indices/bufferView", i2._gltf.bufferViews, d.indices.bufferView), h = a.Get(t2 + "/sparse/values/bufferView", i2._gltf.bufferViews, d.values.bufferView);
                return Promise.all([i2.loadBufferViewAsync("/bufferViews/" + f.index, f), i2.loadBufferViewAsync("/bufferViews/" + h.index, h)]).then(function(a2) {
                  var i3, u3 = a2[0], f2 = a2[1], h2 = e3._GetTypedArray(t2 + "/sparse/indices", d.indices.componentType, u3, d.indices.byteOffset, d.count), p = s * d.count;
                  if (n2.componentType !== 5126 || n2.normalized) {
                    var _ = e3._GetTypedArray(t2 + "/sparse/values", n2.componentType, f2, d.values.byteOffset, p);
                    i3 = new o2(p), r.VertexBuffer.ForEach(_, 0, l, s, n2.componentType, i3.length, n2.normalized || false, function(e4, t3) {
                      i3[t3] = e4;
                    });
                  } else
                    i3 = e3._GetTypedArray(t2 + "/sparse/values", n2.componentType, f2, d.values.byteOffset, p);
                  for (var m = 0, y = 0; y < h2.length; y++)
                    for (var b = h2[y] * s, v = 0; v < s; v++)
                      c2[b++] = i3[m++];
                  return c2;
                });
              });
            }
            return n2._data;
          }, e3.prototype._loadFloatAccessorAsync = function(e4, t2) {
            return this._loadAccessorAsync(e4, t2, Float32Array);
          }, e3.prototype._loadIndicesAccessorAsync = function(t2, n2) {
            if (n2.type !== "SCALAR")
              throw new Error(t2 + "/type: Invalid value " + n2.type);
            if (n2.componentType !== 5121 && n2.componentType !== 5123 && n2.componentType !== 5125)
              throw new Error(t2 + "/componentType: Invalid value " + n2.componentType);
            if (n2._data)
              return n2._data;
            if (n2.sparse) {
              var r2 = e3._GetTypedArrayConstructor(t2 + "/componentType", n2.componentType);
              n2._data = this._loadAccessorAsync(t2, n2, r2);
            } else {
              var o2 = a.Get(t2 + "/bufferView", this._gltf.bufferViews, n2.bufferView);
              n2._data = this.loadBufferViewAsync("/bufferViews/" + o2.index, o2).then(function(r3) {
                return e3._GetTypedArray(t2, n2.componentType, r3, n2.byteOffset, n2.count);
              });
            }
            return n2._data;
          }, e3.prototype._loadVertexBufferViewAsync = function(e4, t2) {
            var n2 = this;
            return e4._babylonBuffer || (e4._babylonBuffer = this.loadBufferViewAsync("/bufferViews/" + e4.index, e4).then(function(e5) {
              return new r.Buffer(n2._babylonScene.getEngine(), e5, false);
            })), e4._babylonBuffer;
          }, e3.prototype._loadVertexAccessorAsync = function(t2, n2, o2) {
            var i2 = this;
            if (n2._babylonVertexBuffer)
              return n2._babylonVertexBuffer;
            if (n2.sparse)
              n2._babylonVertexBuffer = this._loadFloatAccessorAsync("/accessors/" + n2.index, n2).then(function(e4) {
                return new r.VertexBuffer(i2._babylonScene.getEngine(), e4, o2, false);
              });
            else if (n2.byteOffset && n2.byteOffset % r.VertexBuffer.GetTypeByteLength(n2.componentType) != 0)
              r.Logger.Warn("Accessor byte offset is not a multiple of component type byte length"), n2._babylonVertexBuffer = this._loadFloatAccessorAsync("/accessors/" + n2.index, n2).then(function(e4) {
                return new r.VertexBuffer(i2._babylonScene.getEngine(), e4, o2, false);
              });
            else if (o2 === r.VertexBuffer.MatricesIndicesKind || o2 === r.VertexBuffer.MatricesIndicesExtraKind)
              n2._babylonVertexBuffer = this._loadFloatAccessorAsync("/accessors/" + n2.index, n2).then(function(e4) {
                return new r.VertexBuffer(i2._babylonScene.getEngine(), e4, o2, false);
              });
            else {
              var s = a.Get(t2 + "/bufferView", this._gltf.bufferViews, n2.bufferView);
              n2._babylonVertexBuffer = this._loadVertexBufferViewAsync(s, o2).then(function(a2) {
                var l = e3._GetNumComponents(t2, n2.type);
                return new r.VertexBuffer(i2._babylonScene.getEngine(), a2, o2, false, false, s.byteStride, false, n2.byteOffset, l, n2.componentType, n2.normalized, true, 1, true);
              });
            }
            return n2._babylonVertexBuffer;
          }, e3.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var o2 = new Array();
            return t2 && (t2.baseColorFactor ? (n2.albedoColor = r.Color3.FromArray(t2.baseColorFactor), n2.alpha = t2.baseColorFactor[3]) : n2.albedoColor = r.Color3.White(), n2.metallic = t2.metallicFactor == null ? 1 : t2.metallicFactor, n2.roughness = t2.roughnessFactor == null ? 1 : t2.roughnessFactor, t2.baseColorTexture && o2.push(this.loadTextureInfoAsync(e4 + "/baseColorTexture", t2.baseColorTexture, function(e5) {
              e5.name = n2.name + " (Base Color)", n2.albedoTexture = e5;
            })), t2.metallicRoughnessTexture && (t2.metallicRoughnessTexture.nonColorData = true, o2.push(this.loadTextureInfoAsync(e4 + "/metallicRoughnessTexture", t2.metallicRoughnessTexture, function(e5) {
              e5.name = n2.name + " (Metallic Roughness)", n2.metallicTexture = e5;
            })), n2.useMetallnessFromMetallicTextureBlue = true, n2.useRoughnessFromMetallicTextureGreen = true, n2.useRoughnessFromMetallicTextureAlpha = false)), Promise.all(o2).then(function() {
            });
          }, e3.prototype._loadMaterialAsync = function(t2, n2, r2, o2, a2) {
            a2 === void 0 && (a2 = function() {
            });
            var i2 = this._extensionsLoadMaterialAsync(t2, n2, r2, o2, a2);
            if (i2)
              return i2;
            n2._data = n2._data || {};
            var s = n2._data[o2];
            if (!s) {
              this.logOpen(t2 + " " + (n2.name || ""));
              var l = this.createMaterial(t2, n2, o2);
              s = { babylonMaterial: l, babylonMeshes: [], promise: this.loadMaterialPropertiesAsync(t2, n2, l) }, n2._data[o2] = s, e3.AddPointerMetadata(l, t2), this._parent.onMaterialLoadedObservable.notifyObservers(l), this.logClose();
            }
            return r2 && (s.babylonMeshes.push(r2), r2.onDisposeObservable.addOnce(function() {
              var e4 = s.babylonMeshes.indexOf(r2);
              e4 !== -1 && s.babylonMeshes.splice(e4, 1);
            })), a2(s.babylonMaterial), s.promise.then(function() {
              return s.babylonMaterial;
            });
          }, e3.prototype._createDefaultMaterial = function(e4, t2) {
            this._babylonScene._blockEntityCollection = this._forAssetContainer;
            var n2 = new r.PBRMaterial(e4, this._babylonScene);
            return this._babylonScene._blockEntityCollection = false, n2.fillMode = t2, n2.enableSpecularAntiAliasing = true, n2.useRadianceOverAlpha = !this._parent.transparencyAsCoverage, n2.useSpecularOverAlpha = !this._parent.transparencyAsCoverage, n2.transparencyMode = r.PBRMaterial.PBRMATERIAL_OPAQUE, n2.metallic = 1, n2.roughness = 1, n2;
          }, e3.prototype.createMaterial = function(e4, t2, n2) {
            var r2 = this._extensionsCreateMaterial(e4, t2, n2);
            if (r2)
              return r2;
            var o2 = t2.name || "material" + t2.index;
            return this._createDefaultMaterial(o2, n2);
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this._extensionsLoadMaterialPropertiesAsync(e4, t2, n2);
            if (r2)
              return r2;
            var o2 = new Array();
            return o2.push(this.loadMaterialBasePropertiesAsync(e4, t2, n2)), t2.pbrMetallicRoughness && o2.push(this._loadMaterialMetallicRoughnessPropertiesAsync(e4 + "/pbrMetallicRoughness", t2.pbrMetallicRoughness, n2)), this.loadMaterialAlphaProperties(e4, t2, n2), Promise.all(o2).then(function() {
            });
          }, e3.prototype.loadMaterialBasePropertiesAsync = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var o2 = new Array();
            return n2.emissiveColor = t2.emissiveFactor ? r.Color3.FromArray(t2.emissiveFactor) : new r.Color3(0, 0, 0), t2.doubleSided && (n2.backFaceCulling = false, n2.twoSidedLighting = true), t2.normalTexture && (t2.normalTexture.nonColorData = true, o2.push(this.loadTextureInfoAsync(e4 + "/normalTexture", t2.normalTexture, function(e5) {
              e5.name = n2.name + " (Normal)", n2.bumpTexture = e5;
            })), n2.invertNormalMapX = !this._babylonScene.useRightHandedSystem, n2.invertNormalMapY = this._babylonScene.useRightHandedSystem, t2.normalTexture.scale != null && (n2.bumpTexture.level = t2.normalTexture.scale), n2.forceIrradianceInFragment = true), t2.occlusionTexture && (t2.occlusionTexture.nonColorData = true, o2.push(this.loadTextureInfoAsync(e4 + "/occlusionTexture", t2.occlusionTexture, function(e5) {
              e5.name = n2.name + " (Occlusion)", n2.ambientTexture = e5;
            })), n2.useAmbientInGrayScale = true, t2.occlusionTexture.strength != null && (n2.ambientTextureStrength = t2.occlusionTexture.strength)), t2.emissiveTexture && o2.push(this.loadTextureInfoAsync(e4 + "/emissiveTexture", t2.emissiveTexture, function(e5) {
              e5.name = n2.name + " (Emissive)", n2.emissiveTexture = e5;
            })), Promise.all(o2).then(function() {
            });
          }, e3.prototype.loadMaterialAlphaProperties = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            switch (t2.alphaMode || "OPAQUE") {
              case "OPAQUE":
                n2.transparencyMode = r.PBRMaterial.PBRMATERIAL_OPAQUE;
                break;
              case "MASK":
                n2.transparencyMode = r.PBRMaterial.PBRMATERIAL_ALPHATEST, n2.alphaCutOff = t2.alphaCutoff == null ? 0.5 : t2.alphaCutoff, n2.albedoTexture && (n2.albedoTexture.hasAlpha = true);
                break;
              case "BLEND":
                n2.transparencyMode = r.PBRMaterial.PBRMATERIAL_ALPHABLEND, n2.albedoTexture && (n2.albedoTexture.hasAlpha = true, n2.useAlphaFromAlbedoTexture = true);
                break;
              default:
                throw new Error(e4 + "/alphaMode: Invalid value (" + t2.alphaMode + ")");
            }
          }, e3.prototype.loadTextureInfoAsync = function(t2, n2, r2) {
            var o2 = this;
            r2 === void 0 && (r2 = function() {
            });
            var i2 = this._extensionsLoadTextureInfoAsync(t2, n2, r2);
            if (i2)
              return i2;
            if (this.logOpen("" + t2), n2.texCoord >= 2)
              throw new Error(t2 + "/texCoord: Invalid value (" + n2.texCoord + ")");
            var s = a.Get(t2 + "/index", this._gltf.textures, n2.index);
            s._textureInfo = n2;
            var l = this._loadTextureAsync("/textures/" + n2.index, s, function(a2) {
              a2.coordinatesIndex = n2.texCoord || 0, e3.AddPointerMetadata(a2, t2), o2._parent.onTextureLoadedObservable.notifyObservers(a2), r2(a2);
            });
            return this.logClose(), l;
          }, e3.prototype._loadTextureAsync = function(t2, n2, r2) {
            r2 === void 0 && (r2 = function() {
            });
            var o2 = this._extensionsLoadTextureAsync(t2, n2, r2);
            if (o2)
              return o2;
            this.logOpen(t2 + " " + (n2.name || ""));
            var i2 = n2.sampler == null ? e3.DefaultSampler : a.Get(t2 + "/sampler", this._gltf.samplers, n2.sampler), s = a.Get(t2 + "/source", this._gltf.images, n2.source), l = this._createTextureAsync(t2, i2, s, r2);
            return this.logClose(), l;
          }, e3.prototype._createTextureAsync = function(e4, t2, n2, o2, a2) {
            var i2 = this;
            o2 === void 0 && (o2 = function() {
            });
            var s = this._loadSampler("/samplers/" + t2.index, t2), l = new Array(), u = new r.Deferred();
            this._babylonScene._blockEntityCollection = this._forAssetContainer;
            var c = new r.Texture(null, this._babylonScene, s.noMipMaps, false, s.samplingMode, function() {
              i2._disposed || u.resolve();
            }, function(t3, n3) {
              i2._disposed || u.reject(new Error(e4 + ": " + (n3 && n3.message ? n3.message : t3 || "Failed to load texture")));
            }, void 0, void 0, void 0, n2.mimeType, a2);
            return this._babylonScene._blockEntityCollection = false, l.push(u.promise), l.push(this.loadImageAsync("/images/" + n2.index, n2).then(function(e5) {
              var t3 = n2.uri || i2._fileName + "#image" + n2.index, r2 = "data:" + i2._uniqueRootUrl + t3;
              c.updateURL(r2, e5);
            })), c.wrapU = s.wrapU, c.wrapV = s.wrapV, o2(c), Promise.all(l).then(function() {
              return c;
            });
          }, e3.prototype._loadSampler = function(t2, n2) {
            return n2._data || (n2._data = { noMipMaps: n2.minFilter === 9728 || n2.minFilter === 9729, samplingMode: e3._GetTextureSamplingMode(t2, n2), wrapU: e3._GetTextureWrapMode(t2 + "/wrapS", n2.wrapS), wrapV: e3._GetTextureWrapMode(t2 + "/wrapT", n2.wrapT) }), n2._data;
          }, e3.prototype.loadImageAsync = function(e4, t2) {
            if (!t2._data) {
              if (this.logOpen(e4 + " " + (t2.name || "")), t2.uri)
                t2._data = this.loadUriAsync(e4 + "/uri", t2, t2.uri);
              else {
                var n2 = a.Get(e4 + "/bufferView", this._gltf.bufferViews, t2.bufferView);
                t2._data = this.loadBufferViewAsync("/bufferViews/" + n2.index, n2);
              }
              this.logClose();
            }
            return t2._data;
          }, e3.prototype.loadUriAsync = function(t2, n2, o2) {
            var a2 = this, i2 = this._extensionsLoadUriAsync(t2, n2, o2);
            if (i2)
              return i2;
            if (!e3._ValidateUri(o2))
              throw new Error(t2 + ": '" + o2 + "' is invalid");
            if (r.Tools.IsBase64(o2)) {
              var s = new Uint8Array(r.Tools.DecodeBase64(o2));
              return this.log("Decoded " + o2.substr(0, 64) + "... (" + s.length + " bytes)"), Promise.resolve(s);
            }
            return this.log("Loading " + o2), this._parent.preprocessUrlAsync(this._rootUrl + o2).then(function(e4) {
              return new Promise(function(n3, i3) {
                a2._parent._loadFile(e4, a2._babylonScene, function(e5) {
                  a2._disposed || (a2.log("Loaded " + o2 + " (" + e5.byteLength + " bytes)"), n3(new Uint8Array(e5)));
                }, true, function(e5) {
                  i3(new r.LoadFileError(t2 + ": Failed to load '" + o2 + "'" + (e5 ? ": " + e5.status + " " + e5.statusText : ""), e5));
                });
              });
            });
          }, e3.AddPointerMetadata = function(e4, t2) {
            var n2 = e4.metadata = e4.metadata || {}, r2 = n2.gltf = n2.gltf || {};
            (r2.pointers = r2.pointers || []).push(t2);
          }, e3._GetTextureWrapMode = function(e4, t2) {
            switch (t2 = t2 == null ? 10497 : t2) {
              case 33071:
                return r.Texture.CLAMP_ADDRESSMODE;
              case 33648:
                return r.Texture.MIRROR_ADDRESSMODE;
              case 10497:
                return r.Texture.WRAP_ADDRESSMODE;
              default:
                return r.Logger.Warn(e4 + ": Invalid value (" + t2 + ")"), r.Texture.WRAP_ADDRESSMODE;
            }
          }, e3._GetTextureSamplingMode = function(e4, t2) {
            var n2 = t2.magFilter == null ? 9729 : t2.magFilter, o2 = t2.minFilter == null ? 9987 : t2.minFilter;
            if (n2 === 9729)
              switch (o2) {
                case 9728:
                  return r.Texture.LINEAR_NEAREST;
                case 9729:
                  return r.Texture.LINEAR_LINEAR;
                case 9984:
                  return r.Texture.LINEAR_NEAREST_MIPNEAREST;
                case 9985:
                  return r.Texture.LINEAR_LINEAR_MIPNEAREST;
                case 9986:
                  return r.Texture.LINEAR_NEAREST_MIPLINEAR;
                case 9987:
                  return r.Texture.LINEAR_LINEAR_MIPLINEAR;
                default:
                  return r.Logger.Warn(e4 + "/minFilter: Invalid value (" + o2 + ")"), r.Texture.LINEAR_LINEAR_MIPLINEAR;
              }
            else
              switch (n2 !== 9728 && r.Logger.Warn(e4 + "/magFilter: Invalid value (" + n2 + ")"), o2) {
                case 9728:
                  return r.Texture.NEAREST_NEAREST;
                case 9729:
                  return r.Texture.NEAREST_LINEAR;
                case 9984:
                  return r.Texture.NEAREST_NEAREST_MIPNEAREST;
                case 9985:
                  return r.Texture.NEAREST_LINEAR_MIPNEAREST;
                case 9986:
                  return r.Texture.NEAREST_NEAREST_MIPLINEAR;
                case 9987:
                  return r.Texture.NEAREST_LINEAR_MIPLINEAR;
                default:
                  return r.Logger.Warn(e4 + "/minFilter: Invalid value (" + o2 + ")"), r.Texture.NEAREST_NEAREST_MIPNEAREST;
              }
          }, e3._GetTypedArrayConstructor = function(e4, t2) {
            switch (t2) {
              case 5120:
                return Int8Array;
              case 5121:
                return Uint8Array;
              case 5122:
                return Int16Array;
              case 5123:
                return Uint16Array;
              case 5125:
                return Uint32Array;
              case 5126:
                return Float32Array;
              default:
                throw new Error(e4 + ": Invalid component type " + t2);
            }
          }, e3._GetTypedArray = function(t2, n2, r2, o2, a2) {
            var i2 = r2.buffer;
            o2 = r2.byteOffset + (o2 || 0);
            var s = e3._GetTypedArrayConstructor(t2 + "/componentType", n2);
            try {
              return new s(i2, o2, a2);
            } catch (e4) {
              throw new Error(t2 + ": " + e4);
            }
          }, e3._GetNumComponents = function(e4, t2) {
            switch (t2) {
              case "SCALAR":
                return 1;
              case "VEC2":
                return 2;
              case "VEC3":
                return 3;
              case "VEC4":
              case "MAT2":
                return 4;
              case "MAT3":
                return 9;
              case "MAT4":
                return 16;
            }
            throw new Error(e4 + ": Invalid type (" + t2 + ")");
          }, e3._ValidateUri = function(e4) {
            return r.Tools.IsBase64(e4) || e4.indexOf("..") === -1;
          }, e3._GetDrawMode = function(e4, t2) {
            switch (t2 == null && (t2 = 4), t2) {
              case 0:
                return r.Material.PointListDrawMode;
              case 1:
                return r.Material.LineListDrawMode;
              case 2:
                return r.Material.LineLoopDrawMode;
              case 3:
                return r.Material.LineStripDrawMode;
              case 4:
                return r.Material.TriangleFillMode;
              case 5:
                return r.Material.TriangleStripDrawMode;
              case 6:
                return r.Material.TriangleFanDrawMode;
            }
            throw new Error(e4 + ": Invalid mesh primitive mode (" + t2 + ")");
          }, e3.prototype._compileMaterialsAsync = function() {
            var e4 = this;
            this._parent._startPerformanceCounter("Compile materials");
            var t2 = new Array();
            if (this._gltf.materials)
              for (var n2 = 0, r2 = this._gltf.materials; n2 < r2.length; n2++) {
                var o2 = r2[n2];
                if (o2._data)
                  for (var a2 in o2._data)
                    for (var i2 = o2._data[a2], s = 0, l = i2.babylonMeshes; s < l.length; s++) {
                      var u = l[s];
                      u.computeWorldMatrix(true);
                      var c = i2.babylonMaterial;
                      t2.push(c.forceCompilationAsync(u)), t2.push(c.forceCompilationAsync(u, { useInstances: true })), this._parent.useClipPlane && (t2.push(c.forceCompilationAsync(u, { clipPlane: true })), t2.push(c.forceCompilationAsync(u, { clipPlane: true, useInstances: true })));
                    }
              }
            return Promise.all(t2).then(function() {
              e4._parent._endPerformanceCounter("Compile materials");
            });
          }, e3.prototype._compileShadowGeneratorsAsync = function() {
            var e4 = this;
            this._parent._startPerformanceCounter("Compile shadow generators");
            for (var t2 = new Array(), n2 = 0, r2 = this._babylonScene.lights; n2 < r2.length; n2++) {
              var o2 = r2[n2].getShadowGenerator();
              o2 && t2.push(o2.forceCompilationAsync());
            }
            return Promise.all(t2).then(function() {
              e4._parent._endPerformanceCounter("Compile shadow generators");
            });
          }, e3.prototype._forEachExtensions = function(e4) {
            for (var t2 = 0, n2 = this._extensions; t2 < n2.length; t2++) {
              var r2 = n2[t2];
              r2.enabled && e4(r2);
            }
          }, e3.prototype._applyExtensions = function(e4, t2, n2) {
            for (var r2 = 0, o2 = this._extensions; r2 < o2.length; r2++) {
              var a2 = o2[r2];
              if (a2.enabled) {
                var i2 = a2.name + "." + t2, s = e4;
                s._activeLoaderExtensionFunctions = s._activeLoaderExtensionFunctions || {};
                var l = s._activeLoaderExtensionFunctions;
                if (!l[i2]) {
                  l[i2] = true;
                  try {
                    var u = n2(a2);
                    if (u)
                      return u;
                  } finally {
                    delete l[i2];
                  }
                }
              }
            }
            return null;
          }, e3.prototype._extensionsOnLoading = function() {
            this._forEachExtensions(function(e4) {
              return e4.onLoading && e4.onLoading();
            });
          }, e3.prototype._extensionsOnReady = function() {
            this._forEachExtensions(function(e4) {
              return e4.onReady && e4.onReady();
            });
          }, e3.prototype._extensionsLoadSceneAsync = function(e4, t2) {
            return this._applyExtensions(t2, "loadScene", function(n2) {
              return n2.loadSceneAsync && n2.loadSceneAsync(e4, t2);
            });
          }, e3.prototype._extensionsLoadNodeAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadNode", function(r2) {
              return r2.loadNodeAsync && r2.loadNodeAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadCameraAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadCamera", function(r2) {
              return r2.loadCameraAsync && r2.loadCameraAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadVertexDataAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadVertexData", function(r2) {
              return r2._loadVertexDataAsync && r2._loadVertexDataAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadMeshPrimitiveAsync = function(e4, t2, n2, r2, o2, a2) {
            return this._applyExtensions(o2, "loadMeshPrimitive", function(i2) {
              return i2._loadMeshPrimitiveAsync && i2._loadMeshPrimitiveAsync(e4, t2, n2, r2, o2, a2);
            });
          }, e3.prototype._extensionsLoadMaterialAsync = function(e4, t2, n2, r2, o2) {
            return this._applyExtensions(t2, "loadMaterial", function(a2) {
              return a2._loadMaterialAsync && a2._loadMaterialAsync(e4, t2, n2, r2, o2);
            });
          }, e3.prototype._extensionsCreateMaterial = function(e4, t2, n2) {
            return this._applyExtensions(t2, "createMaterial", function(r2) {
              return r2.createMaterial && r2.createMaterial(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadMaterialPropertiesAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadMaterialProperties", function(r2) {
              return r2.loadMaterialPropertiesAsync && r2.loadMaterialPropertiesAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadTextureInfoAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadTextureInfo", function(r2) {
              return r2.loadTextureInfoAsync && r2.loadTextureInfoAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadTextureAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadTexture", function(r2) {
              return r2._loadTextureAsync && r2._loadTextureAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadAnimationAsync = function(e4, t2) {
            return this._applyExtensions(t2, "loadAnimation", function(n2) {
              return n2.loadAnimationAsync && n2.loadAnimationAsync(e4, t2);
            });
          }, e3.prototype._extensionsLoadSkinAsync = function(e4, t2, n2) {
            return this._applyExtensions(n2, "loadSkin", function(r2) {
              return r2._loadSkinAsync && r2._loadSkinAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadUriAsync = function(e4, t2, n2) {
            return this._applyExtensions(t2, "loadUri", function(r2) {
              return r2._loadUriAsync && r2._loadUriAsync(e4, t2, n2);
            });
          }, e3.prototype._extensionsLoadBufferViewAsync = function(e4, t2) {
            return this._applyExtensions(t2, "loadBufferView", function(n2) {
              return n2.loadBufferViewAsync && n2.loadBufferViewAsync(e4, t2);
            });
          }, e3.prototype._extensionsLoadBufferAsync = function(e4, t2, n2, r2) {
            return this._applyExtensions(t2, "loadBuffer", function(o2) {
              return o2.loadBufferAsync && o2.loadBufferAsync(e4, t2, n2, r2);
            });
          }, e3.LoadExtensionAsync = function(e4, t2, n2, r2) {
            if (!t2.extensions)
              return null;
            var o2 = t2.extensions[n2];
            return o2 ? r2(e4 + "/extensions/" + n2, o2) : null;
          }, e3.LoadExtraAsync = function(e4, t2, n2, r2) {
            if (!t2.extras)
              return null;
            var o2 = t2.extras[n2];
            return o2 ? r2(e4 + "/extras/" + n2, o2) : null;
          }, e3.prototype.isExtensionUsed = function(e4) {
            return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(e4) !== -1;
          }, e3.prototype.logOpen = function(e4) {
            this._parent._logOpen(e4);
          }, e3.prototype.logClose = function() {
            this._parent._logClose();
          }, e3.prototype.log = function(e4) {
            this._parent._log(e4);
          }, e3.prototype.startPerformanceCounter = function(e4) {
            this._parent._startPerformanceCounter(e4);
          }, e3.prototype.endPerformanceCounter = function(e4) {
            this._parent._endPerformanceCounter(e4);
          }, e3._RegisteredExtensions = {}, e3.DefaultSampler = { index: -1 }, e3;
        }();
        o.GLTFFileLoader._CreateGLTF2Loader = function(e3) {
          return new i(e3);
        };
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "GLTFLoaderCoordinateSystemMode", function() {
          return r;
        }), n.d(t, "GLTFLoaderAnimationStartMode", function() {
          return o;
        }), n.d(t, "GLTFLoaderState", function() {
          return a;
        }), n.d(t, "GLTFFileLoader", function() {
          return l;
        });
        var r, o, a, i = n(0), s = n(3);
        !function(e3) {
          e3[e3.AUTO = 0] = "AUTO", e3[e3.FORCE_RIGHT_HANDED = 1] = "FORCE_RIGHT_HANDED";
        }(r || (r = {})), function(e3) {
          e3[e3.NONE = 0] = "NONE", e3[e3.FIRST = 1] = "FIRST", e3[e3.ALL = 2] = "ALL";
        }(o || (o = {})), function(e3) {
          e3[e3.LOADING = 0] = "LOADING", e3[e3.READY = 1] = "READY", e3[e3.COMPLETE = 2] = "COMPLETE";
        }(a || (a = {}));
        var l = function() {
          function e3() {
            this.onParsedObservable = new i.Observable(), this.coordinateSystemMode = r.AUTO, this.animationStartMode = o.FIRST, this.compileMaterials = false, this.useClipPlane = false, this.compileShadowGenerators = false, this.transparencyAsCoverage = false, this.useRangeRequests = false, this.createInstances = true, this.alwaysComputeBoundingBox = false, this.loadAllMaterials = false, this.preprocessUrlAsync = function(e4) {
              return Promise.resolve(e4);
            }, this.onMeshLoadedObservable = new i.Observable(), this.onTextureLoadedObservable = new i.Observable(), this.onMaterialLoadedObservable = new i.Observable(), this.onCameraLoadedObservable = new i.Observable(), this.onCompleteObservable = new i.Observable(), this.onErrorObservable = new i.Observable(), this.onDisposeObservable = new i.Observable(), this.onExtensionLoadedObservable = new i.Observable(), this.validate = false, this.onValidatedObservable = new i.Observable(), this._loader = null, this._requests = new Array(), this.name = "gltf", this.extensions = { ".gltf": { isBinary: false }, ".glb": { isBinary: true } }, this._logIndentLevel = 0, this._loggingEnabled = false, this._log = this._logDisabled, this._capturePerformanceCounters = false, this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled;
          }
          return Object.defineProperty(e3.prototype, "onParsed", { set: function(e4) {
            this._onParsedObserver && this.onParsedObservable.remove(this._onParsedObserver), this._onParsedObserver = this.onParsedObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onMeshLoaded", { set: function(e4) {
            this._onMeshLoadedObserver && this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver), this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onTextureLoaded", { set: function(e4) {
            this._onTextureLoadedObserver && this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver), this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onMaterialLoaded", { set: function(e4) {
            this._onMaterialLoadedObserver && this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver), this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onCameraLoaded", { set: function(e4) {
            this._onCameraLoadedObserver && this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver), this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onComplete", { set: function(e4) {
            this._onCompleteObserver && this.onCompleteObservable.remove(this._onCompleteObserver), this._onCompleteObserver = this.onCompleteObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onError", { set: function(e4) {
            this._onErrorObserver && this.onErrorObservable.remove(this._onErrorObserver), this._onErrorObserver = this.onErrorObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onDispose", { set: function(e4) {
            this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onExtensionLoaded", { set: function(e4) {
            this._onExtensionLoadedObserver && this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver), this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(e4);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "loggingEnabled", { get: function() {
            return this._loggingEnabled;
          }, set: function(e4) {
            this._loggingEnabled !== e4 && (this._loggingEnabled = e4, this._loggingEnabled ? this._log = this._logEnabled : this._log = this._logDisabled);
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "capturePerformanceCounters", { get: function() {
            return this._capturePerformanceCounters;
          }, set: function(e4) {
            this._capturePerformanceCounters !== e4 && (this._capturePerformanceCounters = e4, this._capturePerformanceCounters ? (this._startPerformanceCounter = this._startPerformanceCounterEnabled, this._endPerformanceCounter = this._endPerformanceCounterEnabled) : (this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled));
          }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "onValidated", { set: function(e4) {
            this._onValidatedObserver && this.onValidatedObservable.remove(this._onValidatedObserver), this._onValidatedObserver = this.onValidatedObservable.add(e4);
          }, enumerable: false, configurable: true }), e3.prototype.dispose = function() {
            this._loader && (this._loader.dispose(), this._loader = null);
            for (var e4 = 0, t2 = this._requests; e4 < t2.length; e4++) {
              t2[e4].abort();
            }
            this._requests.length = 0, delete this._progressCallback, this.preprocessUrlAsync = function(e5) {
              return Promise.resolve(e5);
            }, this.onMeshLoadedObservable.clear(), this.onTextureLoadedObservable.clear(), this.onMaterialLoadedObservable.clear(), this.onCameraLoadedObservable.clear(), this.onCompleteObservable.clear(), this.onExtensionLoadedObservable.clear(), this.onDisposeObservable.notifyObservers(void 0), this.onDisposeObservable.clear();
          }, e3.prototype.requestFile = function(e4, t2, n2, r2, o2, a2) {
            var s2 = this;
            if (this._progressCallback = r2, o2) {
              if (this.useRangeRequests) {
                this.validate && i.Logger.Warn("glTF validation is not supported when range requests are enabled");
                var l2 = { abort: function() {
                }, onCompleteObservable: new i.Observable() }, u = { readAsync: function(n3, r3) {
                  return new Promise(function(o3, a3) {
                    s2._requestFile(t2, e4, function(e5) {
                      o3(new Uint8Array(e5));
                    }, true, function(e5) {
                      a3(e5);
                    }, function(e5) {
                      e5.setRequestHeader("Range", "bytes=" + n3 + "-" + (n3 + r3 - 1));
                    });
                  });
                }, byteLength: 0 };
                return this._unpackBinaryAsync(new i.DataReader(u)).then(function(e5) {
                  l2.onCompleteObservable.notifyObservers(l2), n2(e5);
                }, a2), l2;
              }
              return this._requestFile(t2, e4, function(e5, t3) {
                var r3 = e5;
                s2._unpackBinaryAsync(new i.DataReader({ readAsync: function(e6, t4) {
                  return Promise.resolve(new Uint8Array(r3, e6, t4));
                }, byteLength: r3.byteLength })).then(function(e6) {
                  n2(e6, t3);
                }, a2);
              }, true, a2);
            }
            return this._requestFile(t2, e4, function(r3, o3) {
              s2._validate(e4, r3, i.Tools.GetFolderPath(t2), i.Tools.GetFilename(t2)), n2({ json: s2._parseJson(r3) }, o3);
            }, o2, a2);
          }, e3.prototype.readFile = function(e4, t2, n2, r2, o2, a2) {
            var s2 = this;
            return e4._readFile(t2, function(r3) {
              if (s2._validate(e4, r3, "file:", t2.name), o2) {
                var l2 = r3;
                s2._unpackBinaryAsync(new i.DataReader({ readAsync: function(e5, t3) {
                  return Promise.resolve(new Uint8Array(l2, e5, t3));
                }, byteLength: l2.byteLength })).then(n2, a2);
              } else
                n2({ json: s2._parseJson(r3) });
            }, r2, o2, a2);
          }, e3.prototype.importMeshAsync = function(e4, t2, n2, r2, o2, a2) {
            var i2 = this;
            return Promise.resolve().then(function() {
              return i2.onParsedObservable.notifyObservers(n2), i2.onParsedObservable.clear(), i2._log("Loading " + (a2 || "")), i2._loader = i2._getLoader(n2), i2._loader.importMeshAsync(e4, t2, false, n2, r2, o2, a2);
            });
          }, e3.prototype.loadAsync = function(e4, t2, n2, r2, o2) {
            var a2 = this;
            return Promise.resolve().then(function() {
              return a2.onParsedObservable.notifyObservers(t2), a2.onParsedObservable.clear(), a2._log("Loading " + (o2 || "")), a2._loader = a2._getLoader(t2), a2._loader.loadAsync(e4, t2, n2, r2, o2);
            });
          }, e3.prototype.loadAssetContainerAsync = function(e4, t2, n2, r2, o2) {
            var a2 = this;
            return Promise.resolve().then(function() {
              a2.onParsedObservable.notifyObservers(t2), a2.onParsedObservable.clear(), a2._log("Loading " + (o2 || "")), a2._loader = a2._getLoader(t2);
              var s2 = new i.AssetContainer(e4), l2 = [];
              a2.onMaterialLoadedObservable.add(function(e5) {
                l2.push(e5), e5.onDisposeObservable.addOnce(function() {
                  var t3 = s2.materials.indexOf(e5);
                  t3 > -1 && s2.materials.splice(t3, 1), (t3 = l2.indexOf(e5)) > -1 && l2.splice(t3, 1);
                });
              });
              var u = [];
              a2.onTextureLoadedObservable.add(function(e5) {
                u.push(e5), e5.onDisposeObservable.addOnce(function() {
                  var t3 = s2.textures.indexOf(e5);
                  t3 > -1 && s2.textures.splice(t3, 1), (t3 = u.indexOf(e5)) > -1 && u.splice(t3, 1);
                });
              });
              var c = [];
              return a2.onCameraLoadedObservable.add(function(e5) {
                c.push(e5);
              }), a2._loader.importMeshAsync(null, e4, true, t2, n2, r2, o2).then(function(e5) {
                return Array.prototype.push.apply(s2.geometries, e5.geometries), Array.prototype.push.apply(s2.meshes, e5.meshes), Array.prototype.push.apply(s2.particleSystems, e5.particleSystems), Array.prototype.push.apply(s2.skeletons, e5.skeletons), Array.prototype.push.apply(s2.animationGroups, e5.animationGroups), Array.prototype.push.apply(s2.materials, l2), Array.prototype.push.apply(s2.textures, u), Array.prototype.push.apply(s2.lights, e5.lights), Array.prototype.push.apply(s2.transformNodes, e5.transformNodes), Array.prototype.push.apply(s2.cameras, c), s2;
              });
            });
          }, e3.prototype.canDirectLoad = function(t2) {
            return t2.indexOf("asset") !== -1 && t2.indexOf("version") !== -1 || i.StringTools.StartsWith(t2, "data:base64," + e3.magicBase64Encoded) || i.StringTools.StartsWith(t2, "data:application/octet-stream;base64," + e3.magicBase64Encoded) || i.StringTools.StartsWith(t2, "data:model/gltf-binary;base64," + e3.magicBase64Encoded);
          }, e3.prototype.directLoad = function(t2, n2) {
            if (i.StringTools.StartsWith(n2, "base64," + e3.magicBase64Encoded) || i.StringTools.StartsWith(n2, "application/octet-stream;base64," + e3.magicBase64Encoded) || i.StringTools.StartsWith(n2, "model/gltf-binary;base64," + e3.magicBase64Encoded)) {
              var r2 = i.Tools.DecodeBase64(n2);
              return this._validate(t2, r2), this._unpackBinaryAsync(new i.DataReader({ readAsync: function(e4, t3) {
                return Promise.resolve(new Uint8Array(r2, e4, t3));
              }, byteLength: r2.byteLength }));
            }
            return this._validate(t2, n2), Promise.resolve({ json: this._parseJson(n2) });
          }, e3.prototype.createPlugin = function() {
            return new e3();
          }, Object.defineProperty(e3.prototype, "loaderState", { get: function() {
            return this._loader ? this._loader.state : null;
          }, enumerable: false, configurable: true }), e3.prototype.whenCompleteAsync = function() {
            var e4 = this;
            return new Promise(function(t2, n2) {
              e4.onCompleteObservable.addOnce(function() {
                t2();
              }), e4.onErrorObservable.addOnce(function(e5) {
                n2(e5);
              });
            });
          }, e3.prototype._loadFile = function(e4, t2, n2, r2, o2) {
            var a2 = this, i2 = t2._loadFile(e4, n2, function(e5) {
              a2._onProgress(e5, i2);
            }, void 0, r2, o2);
            return i2.onCompleteObservable.add(function(e5) {
              a2._requests.splice(a2._requests.indexOf(e5), 1);
            }), this._requests.push(i2), i2;
          }, e3.prototype._requestFile = function(e4, t2, n2, r2, o2, a2) {
            var i2 = this, s2 = t2._requestFile(e4, n2, function(e5) {
              i2._onProgress(e5, s2);
            }, void 0, r2, o2, a2);
            return s2.onCompleteObservable.add(function(e5) {
              i2._requests.splice(i2._requests.indexOf(e5), 1);
            }), this._requests.push(s2), s2;
          }, e3.prototype._onProgress = function(e4, t2) {
            if (this._progressCallback) {
              t2._lengthComputable = e4.lengthComputable, t2._loaded = e4.loaded, t2._total = e4.total;
              for (var n2 = true, r2 = 0, o2 = 0, a2 = 0, i2 = this._requests; a2 < i2.length; a2++) {
                var s2 = i2[a2];
                if (s2._lengthComputable === void 0 || s2._loaded === void 0 || s2._total === void 0)
                  return;
                n2 = n2 && s2._lengthComputable, r2 += s2._loaded, o2 += s2._total;
              }
              this._progressCallback({ lengthComputable: n2, loaded: r2, total: n2 ? o2 : 0 });
            }
          }, e3.prototype._validate = function(e4, t2, n2, r2) {
            var o2 = this;
            n2 === void 0 && (n2 = ""), r2 === void 0 && (r2 = ""), this.validate && (this._startPerformanceCounter("Validate JSON"), s.GLTFValidation.ValidateAsync(t2, n2, r2, function(t3) {
              return o2.preprocessUrlAsync(n2 + t3).then(function(t4) {
                return e4._loadFileAsync(t4, void 0, true, true);
              });
            }).then(function(e5) {
              o2._endPerformanceCounter("Validate JSON"), o2.onValidatedObservable.notifyObservers(e5), o2.onValidatedObservable.clear();
            }, function(e5) {
              o2._endPerformanceCounter("Validate JSON"), i.Tools.Warn("Failed to validate: " + e5.message), o2.onValidatedObservable.clear();
            }));
          }, e3.prototype._getLoader = function(t2) {
            var n2 = t2.json.asset || {};
            this._log("Asset version: " + n2.version), n2.minVersion && this._log("Asset minimum version: " + n2.minVersion), n2.generator && this._log("Asset generator: " + n2.generator);
            var r2 = e3._parseVersion(n2.version);
            if (!r2)
              throw new Error("Invalid version: " + n2.version);
            if (n2.minVersion !== void 0) {
              var o2 = e3._parseVersion(n2.minVersion);
              if (!o2)
                throw new Error("Invalid minimum version: " + n2.minVersion);
              if (e3._compareVersion(o2, { major: 2, minor: 0 }) > 0)
                throw new Error("Incompatible minimum version: " + n2.minVersion);
            }
            var a2 = { 1: e3._CreateGLTF1Loader, 2: e3._CreateGLTF2Loader }[r2.major];
            if (!a2)
              throw new Error("Unsupported version: " + n2.version);
            return a2(this);
          }, e3.prototype._parseJson = function(e4) {
            this._startPerformanceCounter("Parse JSON"), this._log("JSON length: " + e4.length);
            var t2 = JSON.parse(e4);
            return this._endPerformanceCounter("Parse JSON"), t2;
          }, e3.prototype._unpackBinaryAsync = function(e4) {
            var t2 = this;
            return this._startPerformanceCounter("Unpack Binary"), e4.loadAsync(20).then(function() {
              var n2 = e4.readUint32();
              if (n2 !== 1179937895)
                throw new Error("Unexpected magic: " + n2);
              var r2 = e4.readUint32();
              t2.loggingEnabled && t2._log("Binary version: " + r2);
              var o2, a2 = e4.readUint32();
              if (e4.buffer.byteLength !== 0 && a2 !== e4.buffer.byteLength)
                throw new Error("Length in header does not match actual data length: " + a2 + " != " + e4.buffer.byteLength);
              switch (r2) {
                case 1:
                  o2 = t2._unpackBinaryV1Async(e4, a2);
                  break;
                case 2:
                  o2 = t2._unpackBinaryV2Async(e4, a2);
                  break;
                default:
                  throw new Error("Unsupported version: " + r2);
              }
              return t2._endPerformanceCounter("Unpack Binary"), o2;
            });
          }, e3.prototype._unpackBinaryV1Async = function(e4, t2) {
            var n2 = e4.readUint32(), r2 = e4.readUint32();
            if (r2 !== 0)
              throw new Error("Unexpected content format: " + r2);
            var o2 = t2 - e4.byteOffset, a2 = { json: this._parseJson(e4.readString(n2)), bin: null };
            if (o2 !== 0) {
              var i2 = e4.byteOffset;
              a2.bin = { readAsync: function(t3, n3) {
                return e4.buffer.readAsync(i2 + t3, n3);
              }, byteLength: o2 };
            }
            return Promise.resolve(a2);
          }, e3.prototype._unpackBinaryV2Async = function(e4, t2) {
            var n2 = this, r2 = 1313821514, o2 = 5130562, a2 = e4.readUint32();
            if (e4.readUint32() !== r2)
              throw new Error("First chunk format is not JSON");
            return e4.byteOffset + a2 === t2 ? e4.loadAsync(a2).then(function() {
              return { json: n2._parseJson(e4.readString(a2)), bin: null };
            }) : e4.loadAsync(a2 + 8).then(function() {
              var i2 = { json: n2._parseJson(e4.readString(a2)), bin: null }, s2 = function() {
                var n3 = e4.readUint32();
                switch (e4.readUint32()) {
                  case r2:
                    throw new Error("Unexpected JSON chunk");
                  case o2:
                    var a3 = e4.byteOffset;
                    i2.bin = { readAsync: function(t3, n4) {
                      return e4.buffer.readAsync(a3 + t3, n4);
                    }, byteLength: n3 }, e4.skipBytes(n3);
                    break;
                  default:
                    e4.skipBytes(n3);
                }
                return e4.byteOffset !== t2 ? e4.loadAsync(8).then(s2) : Promise.resolve(i2);
              };
              return s2();
            });
          }, e3._parseVersion = function(e4) {
            if (e4 === "1.0" || e4 === "1.0.1")
              return { major: 1, minor: 0 };
            var t2 = (e4 + "").match(/^(\d+)\.(\d+)/);
            return t2 ? { major: parseInt(t2[1]), minor: parseInt(t2[2]) } : null;
          }, e3._compareVersion = function(e4, t2) {
            return e4.major > t2.major ? 1 : e4.major < t2.major ? -1 : e4.minor > t2.minor ? 1 : e4.minor < t2.minor ? -1 : 0;
          }, e3.prototype._logOpen = function(e4) {
            this._log(e4), this._logIndentLevel++;
          }, e3.prototype._logClose = function() {
            --this._logIndentLevel;
          }, e3.prototype._logEnabled = function(t2) {
            var n2 = e3._logSpaces.substr(0, 2 * this._logIndentLevel);
            i.Logger.Log("" + n2 + t2);
          }, e3.prototype._logDisabled = function(e4) {
          }, e3.prototype._startPerformanceCounterEnabled = function(e4) {
            i.Tools.StartPerformanceCounter(e4);
          }, e3.prototype._startPerformanceCounterDisabled = function(e4) {
          }, e3.prototype._endPerformanceCounterEnabled = function(e4) {
            i.Tools.EndPerformanceCounter(e4);
          }, e3.prototype._endPerformanceCounterDisabled = function(e4) {
          }, e3.IncrementalLoading = true, e3.HomogeneousCoordinates = false, e3.magicBase64Encoded = "Z2xURg", e3._logSpaces = "                                ", e3;
        }();
        i.SceneLoader && i.SceneLoader.RegisterPlugin(new l());
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "GLTFValidation", function() {
          return i;
        });
        var r = n(0);
        function o(e3, t2, n2, r2) {
          var o2 = { externalResourceFunction: function(e4) {
            return r2(e4).then(function(e5) {
              return new Uint8Array(e5);
            });
          } };
          return n2 && (o2.uri = t2 === "file:" ? n2 : t2 + n2), e3 instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(e3), o2) : GLTFValidator.validateString(e3, o2);
        }
        function a() {
          var e3 = [];
          onmessage = function(t2) {
            var n2 = t2.data;
            switch (n2.id) {
              case "init":
                importScripts(n2.url);
                break;
              case "validate":
                o(n2.data, n2.rootUrl, n2.fileName, function(t3) {
                  return new Promise(function(n3, r2) {
                    var o2 = e3.length;
                    e3.push({ resolve: n3, reject: r2 }), postMessage({ id: "getExternalResource", index: o2, uri: t3 });
                  });
                }).then(function(e4) {
                  postMessage({ id: "validate.resolve", value: e4 });
                }, function(e4) {
                  postMessage({ id: "validate.reject", reason: e4 });
                });
                break;
              case "getExternalResource.resolve":
                e3[n2.index].resolve(n2.value);
                break;
              case "getExternalResource.reject":
                e3[n2.index].reject(n2.reason);
            }
          };
        }
        var i = function() {
          function e3() {
          }
          return e3.ValidateAsync = function(e4, t2, n2, i2) {
            var s = this;
            return typeof Worker == "function" ? new Promise(function(l, u) {
              var c = o + "(" + a + ")()", d = URL.createObjectURL(new Blob([c], { type: "application/javascript" })), f = new Worker(d), h = function(e5) {
                f.removeEventListener("error", h), f.removeEventListener("message", p), u(e5);
              }, p = function(e5) {
                var t3 = e5.data;
                switch (t3.id) {
                  case "getExternalResource":
                    i2(t3.uri).then(function(e6) {
                      f.postMessage({ id: "getExternalResource.resolve", index: t3.index, value: e6 }, [e6]);
                    }, function(e6) {
                      f.postMessage({ id: "getExternalResource.reject", index: t3.index, reason: e6 });
                    });
                    break;
                  case "validate.resolve":
                    f.removeEventListener("error", h), f.removeEventListener("message", p), l(t3.value);
                    break;
                  case "validate.reject":
                    f.removeEventListener("error", h), f.removeEventListener("message", p), u(t3.reason);
                }
              };
              f.addEventListener("error", h), f.addEventListener("message", p), f.postMessage({ id: "init", url: r.Tools.GetAbsoluteUrl(s.Configuration.url) }), f.postMessage({ id: "validate", data: e4, rootUrl: t2, fileName: n2 });
            }) : (this._LoadScriptPromise || (this._LoadScriptPromise = r.Tools.LoadScriptAsync(this.Configuration.url)), this._LoadScriptPromise.then(function() {
              return o(e4, t2, n2, i2);
            }));
          }, e3.Configuration = { url: "https://preview.babylonjs.com/gltf_validator.js" }, e3;
        }();
      }, function(e2, t, n) {
        "use strict";
        n.d(t, "b", function() {
          return o;
        }), n.d(t, "a", function() {
          return a;
        });
        var r = function(e3, t2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t3) {
            e4.__proto__ = t3;
          } || function(e4, t3) {
            for (var n2 in t3)
              Object.prototype.hasOwnProperty.call(t3, n2) && (e4[n2] = t3[n2]);
          })(e3, t2);
        };
        function o(e3, t2) {
          if (typeof t2 != "function" && t2 !== null)
            throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
          function n2() {
            this.constructor = e3;
          }
          r(e3, t2), e3.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
        }
        var a = function() {
          return (a = Object.assign || function(e3) {
            for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var o2 in t2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(t2, o2) && (e3[o2] = t2[o2]);
            return e3;
          }).apply(this, arguments);
        };
        Object.create;
        Object.create;
      }, function(e2, t) {
        var n;
        n = function() {
          return this;
        }();
        try {
          n = n || new Function("return this")();
        } catch (e3) {
          typeof window == "object" && (n = window);
        }
        e2.exports = n;
      }, function(e2, t, n) {
        "use strict";
        n.r(t);
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "EXT_lights_image_based", function() {
          return i;
        }), n.d(t, "EXT_mesh_gpu_instancing", function() {
          return s;
        }), n.d(t, "EXT_texture_webp", function() {
          return l;
        }), n.d(t, "KHR_draco_mesh_compression", function() {
          return u;
        }), n.d(t, "KHR_lights", function() {
          return c;
        }), n.d(t, "KHR_materials_pbrSpecularGlossiness", function() {
          return d;
        }), n.d(t, "KHR_materials_unlit", function() {
          return f;
        }), n.d(t, "KHR_materials_clearcoat", function() {
          return h;
        }), n.d(t, "KHR_materials_sheen", function() {
          return p;
        }), n.d(t, "KHR_materials_specular", function() {
          return _;
        }), n.d(t, "KHR_materials_ior", function() {
          return m;
        }), n.d(t, "KHR_materials_variants", function() {
          return y;
        }), n.d(t, "KHR_materials_transmission", function() {
          return g;
        }), n.d(t, "KHR_materials_translucency", function() {
          return A;
        }), n.d(t, "KHR_mesh_quantization", function() {
          return T;
        }), n.d(t, "KHR_texture_basisu", function() {
          return x;
        }), n.d(t, "KHR_texture_transform", function() {
          return E;
        }), n.d(t, "MSFT_audio_emitter", function() {
          return L;
        }), n.d(t, "MSFT_lod", function() {
          return O;
        }), n.d(t, "MSFT_minecraftMesh", function() {
          return M;
        }), n.d(t, "MSFT_sRGBFactors", function() {
          return S;
        }), n.d(t, "ExtrasAsMetadata", function() {
          return w;
        });
        var r = n(0), o = n(1), a = "EXT_lights_image_based", i = function() {
          function e3(e4) {
            this.name = a, this._loader = e4, this.enabled = this._loader.isExtensionUsed(a);
          }
          return e3.prototype.dispose = function() {
            this._loader = null, delete this._lights;
          }, e3.prototype.onLoading = function() {
            var e4 = this._loader.gltf.extensions;
            if (e4 && e4[this.name]) {
              var t2 = e4[this.name];
              this._lights = t2.lights;
            }
          }, e3.prototype.loadSceneAsync = function(e4, t2) {
            var n2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(r2, a2) {
              var i2 = new Array();
              i2.push(n2._loader.loadSceneAsync(e4, t2)), n2._loader.logOpen("" + r2);
              var s2 = o.a.Get(r2 + "/light", n2._lights, a2.light);
              return i2.push(n2._loadLightAsync("/extensions/" + n2.name + "/lights/" + a2.light, s2).then(function(e5) {
                n2._loader.babylonScene.environmentTexture = e5;
              })), n2._loader.logClose(), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadLightAsync = function(e4, t2) {
            var n2 = this;
            if (!t2._loaded) {
              var a2 = new Array();
              this._loader.logOpen("" + e4);
              for (var i2 = new Array(t2.specularImages.length), s2 = function(n3) {
                var r2 = t2.specularImages[n3];
                i2[n3] = new Array(r2.length);
                for (var s3 = function(t3) {
                  var s4 = e4 + "/specularImages/" + n3 + "/" + t3;
                  l2._loader.logOpen("" + s4);
                  var u4 = r2[t3], c2 = o.a.Get(s4, l2._loader.gltf.images, u4);
                  a2.push(l2._loader.loadImageAsync("/images/" + u4, c2).then(function(e5) {
                    i2[n3][t3] = e5;
                  })), l2._loader.logClose();
                }, u3 = 0; u3 < r2.length; u3++)
                  s3(u3);
              }, l2 = this, u2 = 0; u2 < t2.specularImages.length; u2++)
                s2(u2);
              this._loader.logClose(), t2._loaded = Promise.all(a2).then(function() {
                var e5 = new r.RawCubeTexture(n2._loader.babylonScene, null, t2.specularImageSize);
                if (e5.name = t2.name || "environment", t2._babylonTexture = e5, t2.intensity != null && (e5.level = t2.intensity), t2.rotation) {
                  var o2 = r.Quaternion.FromArray(t2.rotation);
                  n2._loader.babylonScene.useRightHandedSystem || (o2 = r.Quaternion.Inverse(o2)), r.Matrix.FromQuaternionToRef(o2, e5.getReflectionTextureMatrix());
                }
                var a3 = r.SphericalHarmonics.FromArray(t2.irradianceCoefficients);
                a3.scaleInPlace(t2.intensity), a3.convertIrradianceToLambertianRadiance();
                var s3 = r.SphericalPolynomial.FromHarmonics(a3), l3 = (i2.length - 1) / r.Scalar.Log2(t2.specularImageSize);
                return e5.updateRGBDAsync(i2, s3, l3);
              });
            }
            return t2._loaded.then(function() {
              return t2._babylonTexture;
            });
          }, e3;
        }();
        o.b.RegisterExtension(a, function(e3) {
          return new i(e3);
        });
        var s = function() {
          function e3(e4) {
            this.name = "EXT_mesh_gpu_instancing", this._loader = e4, this.enabled = this._loader.isExtensionUsed("EXT_mesh_gpu_instancing");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadNodeAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(e5, i2) {
              a2._loader._disableInstancedMesh++;
              var s2 = a2._loader.loadNodeAsync("/nodes/" + t2.index, t2, n2);
              if (a2._loader._disableInstancedMesh--, !t2._primitiveBabylonMeshes)
                return s2;
              var l2 = new Array(), u2 = 0, c2 = function(t3) {
                if (i2.attributes[t3] != null) {
                  var n3 = o.a.Get(e5 + "/attributes/" + t3, a2._loader.gltf.accessors, i2.attributes[t3]);
                  if (l2.push(a2._loader._loadFloatAccessorAsync("/accessors/" + n3.bufferView, n3)), u2 === 0)
                    u2 = n3.count;
                  else if (u2 !== n3.count)
                    throw new Error(e5 + "/attributes: Instance buffer accessors do not have the same count.");
                } else
                  l2.push(Promise.resolve(null));
              };
              return c2("TRANSLATION"), c2("ROTATION"), c2("SCALE"), s2.then(function(e6) {
                return Promise.all(l2).then(function(n3) {
                  var o2 = n3[0], a3 = n3[1], i3 = n3[2], s3 = new Float32Array(16 * u2);
                  r.TmpVectors.Vector3[0].copyFromFloats(0, 0, 0), r.TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1), r.TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);
                  for (var l3 = 0; l3 < u2; ++l3)
                    o2 && r.Vector3.FromArrayToRef(o2, 3 * l3, r.TmpVectors.Vector3[0]), a3 && r.Quaternion.FromArrayToRef(a3, 4 * l3, r.TmpVectors.Quaternion[0]), i3 && r.Vector3.FromArrayToRef(i3, 3 * l3, r.TmpVectors.Vector3[1]), r.Matrix.ComposeToRef(r.TmpVectors.Vector3[1], r.TmpVectors.Quaternion[0], r.TmpVectors.Vector3[0], r.TmpVectors.Matrix[0]), r.TmpVectors.Matrix[0].copyToArray(s3, 16 * l3);
                  for (var c3 = 0, d2 = t2._primitiveBabylonMeshes; c3 < d2.length; c3++) {
                    d2[c3].thinInstanceSetBuffer("matrix", s3, 16, true);
                  }
                  return e6;
                });
              });
            });
          }, e3;
        }();
        o.b.RegisterExtension("EXT_mesh_gpu_instancing", function(e3) {
          return new s(e3);
        });
        var l = function() {
          function e3(e4) {
            this.name = "EXT_texture_webp", this._loader = e4, this.enabled = e4.isExtensionUsed("EXT_texture_webp");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype._loadTextureAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(a2, i2) {
              var s2 = t2.sampler == null ? o.b.DefaultSampler : o.a.Get(e4 + "/sampler", r2._loader.gltf.samplers, t2.sampler), l2 = o.a.Get(a2 + "/source", r2._loader.gltf.images, i2.source);
              return r2._loader._createTextureAsync(e4, s2, l2, function(e5) {
                n2(e5);
              });
            });
          }, e3;
        }();
        o.b.RegisterExtension("EXT_texture_webp", function(e3) {
          return new l(e3);
        });
        var u = function() {
          function e3(e4) {
            this.name = "KHR_draco_mesh_compression", this._loader = e4, this.enabled = r.DracoCompression.DecoderAvailable && this._loader.isExtensionUsed("KHR_draco_mesh_compression");
          }
          return e3.prototype.dispose = function() {
            delete this.dracoCompression, this._loader = null;
          }, e3.prototype._loadVertexDataAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(i2, s2) {
              if (t2.mode != null) {
                if (t2.mode !== 5 && t2.mode !== 4)
                  throw new Error(e4 + ": Unsupported mode " + t2.mode);
                if (t2.mode === 5)
                  throw new Error(e4 + ": Mode " + t2.mode + " is not currently supported");
              }
              var l2 = {}, u2 = function(e5, t3) {
                var r2 = s2.attributes[e5];
                r2 != null && (n2._delayInfo = n2._delayInfo || [], n2._delayInfo.indexOf(t3) === -1 && n2._delayInfo.push(t3), l2[t3] = r2);
              };
              u2("POSITION", r.VertexBuffer.PositionKind), u2("NORMAL", r.VertexBuffer.NormalKind), u2("TANGENT", r.VertexBuffer.TangentKind), u2("TEXCOORD_0", r.VertexBuffer.UVKind), u2("TEXCOORD_1", r.VertexBuffer.UV2Kind), u2("JOINTS_0", r.VertexBuffer.MatricesIndicesKind), u2("WEIGHTS_0", r.VertexBuffer.MatricesWeightsKind), u2("COLOR_0", r.VertexBuffer.ColorKind);
              var c2 = o.a.Get(i2, a2._loader.gltf.bufferViews, s2.bufferView);
              return c2._dracoBabylonGeometry || (c2._dracoBabylonGeometry = a2._loader.loadBufferViewAsync("/bufferViews/" + c2.index, c2).then(function(t3) {
                return (a2.dracoCompression || r.DracoCompression.Default).decodeMeshAsync(t3, l2).then(function(e5) {
                  var t4 = new r.Geometry(n2.name, a2._loader.babylonScene);
                  return e5.applyToGeometry(t4), t4;
                }).catch(function(t4) {
                  throw new Error(e4 + ": " + t4.message);
                });
              })), c2._dracoBabylonGeometry;
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_draco_mesh_compression", function(e3) {
          return new u(e3);
        });
        var c = function() {
          function e3(e4) {
            this.name = "KHR_lights_punctual", this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_lights_punctual");
          }
          return e3.prototype.dispose = function() {
            this._loader = null, delete this._lights;
          }, e3.prototype.onLoading = function() {
            var e4 = this._loader.gltf.extensions;
            if (e4 && e4[this.name]) {
              var t2 = e4[this.name];
              this._lights = t2.lights;
            }
          }, e3.prototype.loadNodeAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(i2, s2) {
              return a2._loader.loadNodeAsync(e4, t2, function(e5) {
                var t3, l2 = o.a.Get(i2, a2._lights, s2.light), u2 = l2.name || e5.name;
                switch (a2._loader.babylonScene._blockEntityCollection = a2._loader._forAssetContainer, l2.type) {
                  case "directional":
                    t3 = new r.DirectionalLight(u2, r.Vector3.Backward(), a2._loader.babylonScene);
                    break;
                  case "point":
                    t3 = new r.PointLight(u2, r.Vector3.Zero(), a2._loader.babylonScene);
                    break;
                  case "spot":
                    var c2 = new r.SpotLight(u2, r.Vector3.Zero(), r.Vector3.Backward(), 0, 1, a2._loader.babylonScene);
                    c2.angle = 2 * (l2.spot && l2.spot.outerConeAngle || Math.PI / 4), c2.innerAngle = 2 * (l2.spot && l2.spot.innerConeAngle || 0), t3 = c2;
                    break;
                  default:
                    throw a2._loader.babylonScene._blockEntityCollection = false, new Error(i2 + ": Invalid light type (" + l2.type + ")");
                }
                a2._loader.babylonScene._blockEntityCollection = false, t3.falloffType = r.Light.FALLOFF_GLTF, t3.diffuse = l2.color ? r.Color3.FromArray(l2.color) : r.Color3.White(), t3.intensity = l2.intensity == null ? 1 : l2.intensity, t3.range = l2.range == null ? Number.MAX_VALUE : l2.range, t3.parent = e5, a2._loader._babylonLights.push(t3), o.b.AddPointerMetadata(t3, i2), n2(e5);
              });
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_lights_punctual", function(e3) {
          return new c(e3);
        });
        var d = function() {
          function e3(e4) {
            this.name = "KHR_materials_pbrSpecularGlossiness", this.order = 200, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_pbrSpecularGlossiness");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialBasePropertiesAsync(e4, t2, n2)), i2.push(r2._loadSpecularGlossinessPropertiesAsync(o2, t2, a2, n2)), r2._loader.loadMaterialAlphaProperties(e4, t2, n2), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadSpecularGlossinessPropertiesAsync = function(e4, t2, n2, o2) {
            if (!(o2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var a2 = new Array();
            return o2.metallic = null, o2.roughness = null, n2.diffuseFactor ? (o2.albedoColor = r.Color3.FromArray(n2.diffuseFactor), o2.alpha = n2.diffuseFactor[3]) : o2.albedoColor = r.Color3.White(), o2.reflectivityColor = n2.specularFactor ? r.Color3.FromArray(n2.specularFactor) : r.Color3.White(), o2.microSurface = n2.glossinessFactor == null ? 1 : n2.glossinessFactor, n2.diffuseTexture && a2.push(this._loader.loadTextureInfoAsync(e4 + "/diffuseTexture", n2.diffuseTexture, function(e5) {
              e5.name = o2.name + " (Diffuse)", o2.albedoTexture = e5;
            })), n2.specularGlossinessTexture && (n2.specularGlossinessTexture.nonColorData = true, a2.push(this._loader.loadTextureInfoAsync(e4 + "/specularGlossinessTexture", n2.specularGlossinessTexture, function(e5) {
              e5.name = o2.name + " (Specular Glossiness)", o2.reflectivityTexture = e5;
            })), o2.reflectivityTexture.hasAlpha = true, o2.useMicroSurfaceFromReflectivityMapAlpha = true), Promise.all(a2).then(function() {
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_pbrSpecularGlossiness", function(e3) {
          return new d(e3);
        });
        var f = function() {
          function e3(e4) {
            this.name = "KHR_materials_unlit", this.order = 210, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_unlit");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function() {
              return r2._loadUnlitPropertiesAsync(e4, t2, n2);
            });
          }, e3.prototype._loadUnlitPropertiesAsync = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var o2 = new Array();
            n2.unlit = true;
            var a2 = t2.pbrMetallicRoughness;
            return a2 && (a2.baseColorFactor ? (n2.albedoColor = r.Color3.FromArray(a2.baseColorFactor), n2.alpha = a2.baseColorFactor[3]) : n2.albedoColor = r.Color3.White(), a2.baseColorTexture && o2.push(this._loader.loadTextureInfoAsync(e4 + "/baseColorTexture", a2.baseColorTexture, function(e5) {
              e5.name = n2.name + " (Base Color)", n2.albedoTexture = e5;
            }))), t2.doubleSided && (n2.backFaceCulling = false, n2.twoSidedLighting = true), this._loader.loadMaterialAlphaProperties(e4, t2, n2), Promise.all(o2).then(function() {
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_unlit", function(e3) {
          return new f(e3);
        });
        var h = function() {
          function e3(e4) {
            this.name = "KHR_materials_clearcoat", this.order = 190, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_clearcoat");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialPropertiesAsync(e4, t2, n2)), i2.push(r2._loadClearCoatPropertiesAsync(o2, a2, n2)), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadClearCoatPropertiesAsync = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var o2 = new Array();
            return n2.clearCoat.isEnabled = true, n2.clearCoat.useRoughnessFromMainTexture = false, n2.clearCoat.remapF0OnInterfaceChange = false, t2.clearcoatFactor != null ? n2.clearCoat.intensity = t2.clearcoatFactor : n2.clearCoat.intensity = 0, t2.clearcoatTexture && o2.push(this._loader.loadTextureInfoAsync(e4 + "/clearcoatTexture", t2.clearcoatTexture, function(e5) {
              e5.name = n2.name + " (ClearCoat Intensity)", n2.clearCoat.texture = e5;
            })), t2.clearcoatRoughnessFactor != null ? n2.clearCoat.roughness = t2.clearcoatRoughnessFactor : n2.clearCoat.roughness = 0, t2.clearcoatRoughnessTexture && (t2.clearcoatRoughnessTexture.nonColorData = true, o2.push(this._loader.loadTextureInfoAsync(e4 + "/clearcoatRoughnessTexture", t2.clearcoatRoughnessTexture, function(e5) {
              e5.name = n2.name + " (ClearCoat Roughness)", n2.clearCoat.textureRoughness = e5;
            }))), t2.clearcoatNormalTexture && (t2.clearcoatNormalTexture.nonColorData = true, o2.push(this._loader.loadTextureInfoAsync(e4 + "/clearcoatNormalTexture", t2.clearcoatNormalTexture, function(e5) {
              e5.name = n2.name + " (ClearCoat Normal)", n2.clearCoat.bumpTexture = e5;
            })), n2.invertNormalMapX = !n2.getScene().useRightHandedSystem, n2.invertNormalMapY = n2.getScene().useRightHandedSystem, t2.clearcoatNormalTexture.scale != null && (n2.clearCoat.bumpTexture.level = t2.clearcoatNormalTexture.scale)), Promise.all(o2).then(function() {
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_clearcoat", function(e3) {
          return new h(e3);
        });
        var p = function() {
          function e3(e4) {
            this.name = "KHR_materials_sheen", this.order = 190, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_sheen");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialPropertiesAsync(e4, t2, n2)), i2.push(r2._loadSheenPropertiesAsync(o2, a2, n2)), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadSheenPropertiesAsync = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var o2 = new Array();
            return n2.sheen.isEnabled = true, n2.sheen.intensity = 1, t2.sheenColorFactor != null ? n2.sheen.color = r.Color3.FromArray(t2.sheenColorFactor) : n2.sheen.color = r.Color3.Black(), t2.sheenColorTexture && o2.push(this._loader.loadTextureInfoAsync(e4 + "/sheenColorTexture", t2.sheenColorTexture, function(e5) {
              e5.name = n2.name + " (Sheen Color)", n2.sheen.texture = e5;
            })), t2.sheenRoughnessFactor !== void 0 ? n2.sheen.roughness = t2.sheenRoughnessFactor : n2.sheen.roughness = 0, t2.sheenRoughnessTexture && (t2.sheenRoughnessTexture.nonColorData = true, o2.push(this._loader.loadTextureInfoAsync(e4 + "/sheenRoughnessTexture", t2.sheenRoughnessTexture, function(e5) {
              e5.name = n2.name + " (Sheen Roughness)", n2.sheen.textureRoughness = e5;
            }))), n2.sheen.albedoScaling = true, n2.sheen.useRoughnessFromMainTexture = false, Promise.all(o2).then(function() {
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_sheen", function(e3) {
          return new p(e3);
        });
        var _ = function() {
          function e3(e4) {
            this.name = "KHR_materials_specular", this.order = 190, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_specular");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialPropertiesAsync(e4, t2, n2)), i2.push(r2._loadSpecularPropertiesAsync(o2, a2, n2)), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadSpecularPropertiesAsync = function(e4, t2, n2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var o2 = new Array();
            return t2.specularFactor !== void 0 && (n2.metallicF0Factor = t2.specularFactor), t2.specularColorFactor !== void 0 && (n2.metallicReflectanceColor = r.Color3.FromArray(t2.specularColorFactor)), t2.specularTexture && (t2.specularTexture.nonColorData = true, o2.push(this._loader.loadTextureInfoAsync(e4 + "/specularTexture", t2.specularTexture, function(e5) {
              e5.name = n2.name + " (Specular F0 Color)", n2.metallicReflectanceTexture = e5;
            }))), Promise.all(o2).then(function() {
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_specular", function(e3) {
          return new _(e3);
        });
        var m = function() {
          function e3(e4) {
            this.name = "KHR_materials_ior", this.order = 180, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_ior");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialPropertiesAsync(e4, t2, n2)), i2.push(r2._loadIorPropertiesAsync(o2, a2, n2)), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadIorPropertiesAsync = function(t2, n2, o2) {
            if (!(o2 instanceof r.PBRMaterial))
              throw new Error(t2 + ": Material type not supported");
            return n2.ior !== void 0 ? o2.indexOfRefraction = n2.ior : o2.indexOfRefraction = e3._DEFAULT_IOR, Promise.resolve();
          }, e3._DEFAULT_IOR = 1.5, e3;
        }();
        o.b.RegisterExtension("KHR_materials_ior", function(e3) {
          return new m(e3);
        });
        var y = function() {
          function e3(e4) {
            this.name = "KHR_materials_variants", this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_variants");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.GetAvailableVariants = function(e4) {
            var t2 = this._GetExtensionMetadata(e4);
            return t2 ? Object.keys(t2.variants) : [];
          }, e3.prototype.getAvailableVariants = function(t2) {
            return e3.GetAvailableVariants(t2);
          }, e3.SelectVariant = function(e4, t2) {
            var n2 = this._GetExtensionMetadata(e4);
            if (!n2)
              throw new Error("Cannot select variant on a glTF mesh that does not have the KHR_materials_variants extension");
            var r2 = function(e5) {
              var t3 = n2.variants[e5];
              if (t3)
                for (var r3 = 0, o3 = t3; r3 < o3.length; r3++) {
                  var a3 = o3[r3];
                  a3.mesh.material = a3.material;
                }
            };
            if (t2 instanceof Array)
              for (var o2 = 0, a2 = t2; o2 < a2.length; o2++) {
                r2(a2[o2]);
              }
            else
              r2(t2);
            n2.lastSelected = t2;
          }, e3.prototype.selectVariant = function(t2, n2) {
            return e3.SelectVariant(t2, n2);
          }, e3.Reset = function(e4) {
            var t2 = this._GetExtensionMetadata(e4);
            if (!t2)
              throw new Error("Cannot reset on a glTF mesh that does not have the KHR_materials_variants extension");
            for (var n2 = 0, r2 = t2.original; n2 < r2.length; n2++) {
              var o2 = r2[n2];
              o2.mesh.material = o2.material;
            }
            t2.lastSelected = null;
          }, e3.prototype.reset = function(t2) {
            return e3.Reset(t2);
          }, e3.GetLastSelectedVariant = function(e4) {
            var t2 = this._GetExtensionMetadata(e4);
            if (!t2)
              throw new Error("Cannot get the last selected variant on a glTF mesh that does not have the KHR_materials_variants extension");
            return t2.lastSelected;
          }, e3.prototype.getLastSelectedVariant = function(t2) {
            return e3.GetLastSelectedVariant(t2);
          }, e3._GetExtensionMetadata = function(e4) {
            var t2, n2;
            return ((n2 = (t2 = e4 == null ? void 0 : e4.metadata) === null || t2 === void 0 ? void 0 : t2.gltf) === null || n2 === void 0 ? void 0 : n2.KHR_materials_variants) || null;
          }, e3.prototype.onLoading = function() {
            var e4 = this._loader.gltf.extensions;
            if (e4 && e4[this.name]) {
              var t2 = e4[this.name];
              this._variants = t2.variants;
            }
          }, e3.prototype._loadMeshPrimitiveAsync = function(e4, t2, n2, a2, i2, s2) {
            var l2 = this;
            return o.b.LoadExtensionAsync(e4, i2, this.name, function(u2, c2) {
              var d2 = new Array();
              return d2.push(l2._loader._loadMeshPrimitiveAsync(e4, t2, n2, a2, i2, function(t3) {
                if (s2(t3), t3 instanceof r.Mesh) {
                  var n3 = o.b._GetDrawMode(e4, i2.mode), a3 = l2._loader.rootBabylonMesh, f2 = a3.metadata = a3.metadata || {}, h2 = f2.gltf = f2.gltf || {}, p2 = h2.KHR_materials_variants = h2.KHR_materials_variants || { lastSelected: null, original: [], variants: {} };
                  p2.original.push({ mesh: t3, material: t3.material });
                  for (var _2 = p2.variants, m2 = 0, y2 = c2.mappings; m2 < y2.length; m2++)
                    for (var b2 = y2[m2], v2 = function(e5) {
                      var r2 = o.a.Get(u2 + "/mapping/" + e5, l2._variants, e5), a4 = o.a.Get("#/materials/", l2._loader.gltf.materials, b2.material);
                      d2.push(l2._loader._loadMaterialAsync("#/materials/" + b2.material, a4, t3, n3, function(e6) {
                        _2[r2.name] = _2[r2.name] || [], _2[r2.name].push({ mesh: t3, material: e6 });
                      }));
                    }, g2 = 0, A2 = b2.variants; g2 < A2.length; g2++) {
                      v2(A2[g2]);
                    }
                }
              })), Promise.all(d2).then(function(e5) {
                return e5[0];
              });
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_variants", function(e3) {
          return new y(e3);
        });
        var b = n(4), v = function() {
          function e3(t2, n2) {
            var o2 = this;
            this._opaqueRenderTarget = null, this._opaqueMeshesCache = [], this._transparentMeshesCache = [], this._options = Object(b.a)(Object(b.a)({}, e3._getDefaultOptions()), t2), this._scene = n2, this._scene._transmissionHelper = this, this.onErrorObservable = new r.Observable(), this._scene.onDisposeObservable.addOnce(function(e4) {
              o2.dispose();
            }), this._parseScene(), this._setupRenderTargets();
          }
          return e3._getDefaultOptions = function() {
            return { renderSize: 512 };
          }, e3.prototype.updateOptions = function(e4) {
            var t2 = this;
            if (Object.keys(e4).filter(function(n3) {
              return t2._options[n3] !== e4[n3];
            }).length) {
              var n2 = Object(b.a)(Object(b.a)({}, this._options), e4), r2 = this._options;
              this._options = n2, n2.renderSize !== r2.renderSize && this._setupRenderTargets();
            }
          }, e3.prototype.getOpaqueTarget = function() {
            return this._opaqueRenderTarget;
          }, e3.prototype.shouldRenderAsTransmission = function(e4) {
            return !!e4 && !!(e4 instanceof r.PBRMaterial && e4.subSurface.isRefractionEnabled);
          }, e3.prototype._addMesh = function(e4) {
            e4 instanceof r.Mesh && (e4.onMaterialChangedObservable.add(this.onMeshMaterialChanged.bind(this)), this.shouldRenderAsTransmission(e4.material) ? this._transparentMeshesCache.push(e4) : this._opaqueMeshesCache.push(e4));
          }, e3.prototype._removeMesh = function(e4) {
            if (e4 instanceof r.Mesh) {
              e4.onMaterialChangedObservable.remove(this.onMeshMaterialChanged.bind(this));
              var t2 = this._transparentMeshesCache.indexOf(e4);
              t2 !== -1 && this._transparentMeshesCache.splice(t2, 1), (t2 = this._opaqueMeshesCache.indexOf(e4)) !== -1 && this._opaqueMeshesCache.splice(t2, 1);
            }
          }, e3.prototype._parseScene = function() {
            this._scene.meshes.forEach(this._addMesh.bind(this)), this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)), this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
          }, e3.prototype.onMeshMaterialChanged = function(e4) {
            if (e4 instanceof r.Mesh) {
              var t2 = this._transparentMeshesCache.indexOf(e4), n2 = this._opaqueMeshesCache.indexOf(e4);
              this.shouldRenderAsTransmission(e4.material) ? (e4.material instanceof r.PBRMaterial && (e4.material.subSurface.refractionTexture = this._opaqueRenderTarget), n2 !== -1 ? (this._opaqueMeshesCache.splice(n2, 1), this._transparentMeshesCache.push(e4)) : t2 === -1 && this._transparentMeshesCache.push(e4)) : t2 !== -1 ? (this._transparentMeshesCache.splice(t2, 1), this._opaqueMeshesCache.push(e4)) : n2 === -1 && this._opaqueMeshesCache.push(e4);
            }
          }, e3.prototype._setupRenderTargets = function() {
            var e4 = this, t2 = -1;
            if (this._scene.layers && this._opaqueRenderTarget)
              for (var n2 = 0, o2 = this._scene.layers; n2 < o2.length; n2++) {
                var a2 = (l2 = o2[n2]).renderTargetTextures.indexOf(this._opaqueRenderTarget);
                a2 >= 0 && l2.renderTargetTextures.splice(a2, 1);
              }
            if (this._opaqueRenderTarget && (t2 = this._scene.customRenderTargets.indexOf(this._opaqueRenderTarget), this._opaqueRenderTarget.dispose()), this._opaqueRenderTarget = new r.RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, true), this._opaqueRenderTarget.renderList = this._opaqueMeshesCache, this._opaqueRenderTarget.gammaSpace = true, this._opaqueRenderTarget.lodGenerationScale = 1, this._opaqueRenderTarget.lodGenerationOffset = -4, t2 >= 0 ? this._scene.customRenderTargets.splice(t2, 0, this._opaqueRenderTarget) : (t2 = this._scene.customRenderTargets.length, this._scene.customRenderTargets.push(this._opaqueRenderTarget)), this._scene.layers && this._opaqueRenderTarget)
              for (var i2 = 0, s2 = this._scene.layers; i2 < s2.length; i2++) {
                var l2;
                (l2 = s2[i2]).renderTargetTextures.push(this._opaqueRenderTarget);
              }
            this._transparentMeshesCache.forEach(function(t3) {
              e4.shouldRenderAsTransmission(t3.material) && t3.material instanceof r.PBRMaterial && (t3.material.refractionTexture = e4._opaqueRenderTarget);
            });
          }, e3.prototype.dispose = function() {
            this._scene._transmissionHelper = void 0, this._opaqueRenderTarget && (this._opaqueRenderTarget.dispose(), this._opaqueRenderTarget = null), this._transparentMeshesCache = [], this._opaqueMeshesCache = [];
          }, e3;
        }(), g = function() {
          function e3(e4) {
            this.name = "KHR_materials_transmission", this.order = 175, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_transmission"), this.enabled && (e4.parent.transparencyAsCoverage = true);
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialBasePropertiesAsync(e4, t2, n2)), i2.push(r2._loader.loadMaterialPropertiesAsync(e4, t2, n2)), i2.push(r2._loadTransparentPropertiesAsync(o2, t2, n2, a2)), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadTransparentPropertiesAsync = function(e4, t2, n2, o2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var a2 = n2;
            if (a2.subSurface.isRefractionEnabled = true, a2.subSurface.volumeIndexOfRefraction = 1, a2.subSurface.useAlbedoToTintRefraction = true, o2.transmissionFactor === void 0)
              return a2.subSurface.refractionIntensity = 0, a2.subSurface.isRefractionEnabled = false, Promise.resolve();
            a2.subSurface.refractionIntensity = o2.transmissionFactor;
            var i2 = a2.getScene();
            return a2.subSurface.refractionIntensity && !i2._transmissionHelper && new v({}, a2.getScene()), o2.transmissionTexture ? (o2.transmissionTexture.nonColorData = true, this._loader.loadTextureInfoAsync(e4 + "/transmissionTexture", o2.transmissionTexture, void 0).then(function(e5) {
              a2.subSurface.thicknessTexture = e5, a2.subSurface.useMaskFromThicknessTextureGltf = true;
            })) : Promise.resolve();
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_transmission", function(e3) {
          return new g(e3);
        });
        var A = function() {
          function e3(e4) {
            this.name = "KHR_materials_translucency", this.order = 175, this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_materials_translucency"), this.enabled && (e4.parent.transparencyAsCoverage = true);
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, a2) {
              var i2 = new Array();
              return i2.push(r2._loader.loadMaterialBasePropertiesAsync(e4, t2, n2)), i2.push(r2._loader.loadMaterialPropertiesAsync(e4, t2, n2)), i2.push(r2._loadTranslucentPropertiesAsync(o2, t2, n2, a2)), Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype._loadTranslucentPropertiesAsync = function(e4, t2, n2, o2) {
            if (!(n2 instanceof r.PBRMaterial))
              throw new Error(e4 + ": Material type not supported");
            var a2 = n2;
            return a2.subSurface.isTranslucencyEnabled = true, a2.subSurface.volumeIndexOfRefraction = 1, a2.subSurface.minimumThickness = 0, a2.subSurface.maximumThickness = 0, a2.subSurface.useAlbedoToTintRefraction = true, o2.translucencyFactor === void 0 ? (a2.subSurface.translucencyIntensity = 0, a2.subSurface.isTranslucencyEnabled = false, Promise.resolve()) : (a2.subSurface.translucencyIntensity = o2.translucencyFactor, o2.translucencyTexture ? this._loader.loadTextureInfoAsync(e4 + "/translucencyTexture", o2.translucencyTexture).then(function(e5) {
              a2.subSurface.thicknessTexture = e5, a2.subSurface.useMaskFromThicknessTextureGltf = true;
            }) : Promise.resolve());
          }, e3;
        }();
        o.b.RegisterExtension("KHR_materials_translucency", function(e3) {
          return new A(e3);
        });
        var T = function() {
          function e3(e4) {
            this.name = "KHR_mesh_quantization", this.enabled = e4.isExtensionUsed("KHR_mesh_quantization");
          }
          return e3.prototype.dispose = function() {
          }, e3;
        }();
        o.b.RegisterExtension("KHR_mesh_quantization", function(e3) {
          return new T(e3);
        });
        var x = function() {
          function e3(e4) {
            this.name = "KHR_texture_basisu", this._loader = e4, this.enabled = e4.isExtensionUsed("KHR_texture_basisu");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype._loadTextureAsync = function(e4, t2, n2) {
            var r2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(a2, i2) {
              var s2 = t2.sampler == null ? o.b.DefaultSampler : o.a.Get(e4 + "/sampler", r2._loader.gltf.samplers, t2.sampler), l2 = o.a.Get(a2 + "/source", r2._loader.gltf.images, i2.source);
              return r2._loader._createTextureAsync(e4, s2, l2, function(e5) {
                n2(e5);
              }, t2._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : void 0);
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_texture_basisu", function(e3) {
          return new x(e3);
        });
        var E = function() {
          function e3(e4) {
            this.name = "KHR_texture_transform", this._loader = e4, this.enabled = this._loader.isExtensionUsed("KHR_texture_transform");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadTextureInfoAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(o2, i2) {
              return a2._loader.loadTextureInfoAsync(e4, t2, function(e5) {
                if (!(e5 instanceof r.Texture))
                  throw new Error(o2 + ": Texture type not supported");
                i2.offset && (e5.uOffset = i2.offset[0], e5.vOffset = i2.offset[1]), e5.uRotationCenter = 0, e5.vRotationCenter = 0, i2.rotation && (e5.wAng = -i2.rotation), i2.scale && (e5.uScale = i2.scale[0], e5.vScale = i2.scale[1]), i2.texCoord != null && (e5.coordinatesIndex = i2.texCoord), n2(e5);
              });
            });
          }, e3;
        }();
        o.b.RegisterExtension("KHR_texture_transform", function(e3) {
          return new E(e3);
        });
        var L = function() {
          function e3(e4) {
            this.name = "MSFT_audio_emitter", this._loader = e4, this.enabled = this._loader.isExtensionUsed("MSFT_audio_emitter");
          }
          return e3.prototype.dispose = function() {
            this._loader = null, this._clips = null, this._emitters = null;
          }, e3.prototype.onLoading = function() {
            var e4 = this._loader.gltf.extensions;
            if (e4 && e4[this.name]) {
              var t2 = e4[this.name];
              this._clips = t2.clips, this._emitters = t2.emitters, o.a.Assign(this._clips), o.a.Assign(this._emitters);
            }
          }, e3.prototype.loadSceneAsync = function(e4, t2) {
            var n2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(r2, a2) {
              var i2 = new Array();
              i2.push(n2._loader.loadSceneAsync(e4, t2));
              for (var s2 = 0, l2 = a2.emitters; s2 < l2.length; s2++) {
                var u2 = l2[s2], c2 = o.a.Get(r2 + "/emitters", n2._emitters, u2);
                if (c2.refDistance != null || c2.maxDistance != null || c2.rolloffFactor != null || c2.distanceModel != null || c2.innerAngle != null || c2.outerAngle != null)
                  throw new Error(r2 + ": Direction or Distance properties are not allowed on emitters attached to a scene");
                i2.push(n2._loadEmitterAsync(r2 + "/emitters/" + c2.index, c2));
              }
              return Promise.all(i2).then(function() {
              });
            });
          }, e3.prototype.loadNodeAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(e5, i2) {
              var s2 = new Array();
              return a2._loader.loadNodeAsync(e5, t2, function(t3) {
                for (var l2 = function(n3) {
                  var i3 = o.a.Get(e5 + "/emitters", a2._emitters, n3);
                  s2.push(a2._loadEmitterAsync(e5 + "/emitters/" + i3.index, i3).then(function() {
                    for (var e6 = 0, n4 = i3._babylonSounds; e6 < n4.length; e6++) {
                      var o2 = n4[e6];
                      o2.attachToMesh(t3), i3.innerAngle == null && i3.outerAngle == null || (o2.setLocalDirectionToMesh(r.Vector3.Forward()), o2.setDirectionalCone(2 * r.Tools.ToDegrees(i3.innerAngle == null ? Math.PI : i3.innerAngle), 2 * r.Tools.ToDegrees(i3.outerAngle == null ? Math.PI : i3.outerAngle), 0));
                    }
                  }));
                }, u2 = 0, c2 = i2.emitters; u2 < c2.length; u2++) {
                  l2(c2[u2]);
                }
                n2(t3);
              }).then(function(e6) {
                return Promise.all(s2).then(function() {
                  return e6;
                });
              });
            });
          }, e3.prototype.loadAnimationAsync = function(e4, t2) {
            var n2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(r2, a2) {
              return n2._loader.loadAnimationAsync(e4, t2).then(function(i2) {
                var s2 = new Array();
                o.a.Assign(a2.events);
                for (var l2 = 0, u2 = a2.events; l2 < u2.length; l2++) {
                  var c2 = u2[l2];
                  s2.push(n2._loadAnimationEventAsync(r2 + "/events/" + c2.index, e4, t2, c2, i2));
                }
                return Promise.all(s2).then(function() {
                  return i2;
                });
              });
            });
          }, e3.prototype._loadClipAsync = function(e4, t2) {
            if (t2._objectURL)
              return t2._objectURL;
            var n2;
            if (t2.uri)
              n2 = this._loader.loadUriAsync(e4, t2, t2.uri);
            else {
              var r2 = o.a.Get(e4 + "/bufferView", this._loader.gltf.bufferViews, t2.bufferView);
              n2 = this._loader.loadBufferViewAsync("/bufferViews/" + r2.index, r2);
            }
            return t2._objectURL = n2.then(function(e5) {
              return URL.createObjectURL(new Blob([e5], { type: t2.mimeType }));
            }), t2._objectURL;
          }, e3.prototype._loadEmitterAsync = function(e4, t2) {
            var n2 = this;
            if (t2._babylonSounds = t2._babylonSounds || [], !t2._babylonData) {
              for (var a2 = new Array(), i2 = t2.name || "emitter" + t2.index, s2 = { loop: false, autoplay: false, volume: t2.volume == null ? 1 : t2.volume }, l2 = function(e5) {
                var l3 = "/extensions/" + u2.name + "/clips", c3 = o.a.Get(l3, u2._clips, t2.clips[e5].clip);
                a2.push(u2._loadClipAsync(l3 + "/" + t2.clips[e5].clip, c3).then(function(o2) {
                  var a3 = t2._babylonSounds[e5] = new r.Sound(i2, o2, n2._loader.babylonScene, null, s2);
                  a3.refDistance = t2.refDistance || 1, a3.maxDistance = t2.maxDistance || 256, a3.rolloffFactor = t2.rolloffFactor || 1, a3.distanceModel = t2.distanceModel || "exponential", a3._positionInEmitterSpace = true;
                }));
              }, u2 = this, c2 = 0; c2 < t2.clips.length; c2++)
                l2(c2);
              var d2 = Promise.all(a2).then(function() {
                var e5 = t2.clips.map(function(e6) {
                  return e6.weight || 1;
                }), n3 = new r.WeightedSound(t2.loop || false, t2._babylonSounds, e5);
                t2.innerAngle && (n3.directionalConeInnerAngle = 2 * r.Tools.ToDegrees(t2.innerAngle)), t2.outerAngle && (n3.directionalConeOuterAngle = 2 * r.Tools.ToDegrees(t2.outerAngle)), t2.volume && (n3.volume = t2.volume), t2._babylonData.sound = n3;
              });
              t2._babylonData = { loaded: d2 };
            }
            return t2._babylonData.loaded;
          }, e3.prototype._getEventAction = function(e4, t2, n2, r2, o2) {
            switch (n2) {
              case "play":
                return function(e5) {
                  var n3 = (o2 || 0) + (e5 - r2);
                  t2.play(n3);
                };
              case "stop":
                return function(e5) {
                  t2.stop();
                };
              case "pause":
                return function(e5) {
                  t2.pause();
                };
              default:
                throw new Error(e4 + ": Unsupported action " + n2);
            }
          }, e3.prototype._loadAnimationEventAsync = function(e4, t2, n2, a2, i2) {
            var s2 = this;
            if (i2.targetedAnimations.length == 0)
              return Promise.resolve();
            var l2 = i2.targetedAnimations[0], u2 = a2.emitter, c2 = o.a.Get("/extensions/" + this.name + "/emitters", this._emitters, u2);
            return this._loadEmitterAsync(e4, c2).then(function() {
              var t3 = c2._babylonData.sound;
              if (t3) {
                var n3 = new r.AnimationEvent(a2.time, s2._getEventAction(e4, t3, a2.action, a2.time, a2.startOffset));
                l2.animation.addEvent(n3), i2.onAnimationGroupEndObservable.add(function() {
                  t3.stop();
                }), i2.onAnimationGroupPauseObservable.add(function() {
                  t3.pause();
                });
              }
            });
          }, e3;
        }();
        o.b.RegisterExtension("MSFT_audio_emitter", function(e3) {
          return new L(e3);
        });
        var O = function() {
          function e3(e4) {
            this.name = "MSFT_lod", this.order = 100, this.maxLODsToLoad = 10, this.onNodeLODsLoadedObservable = new r.Observable(), this.onMaterialLODsLoadedObservable = new r.Observable(), this._bufferLODs = new Array(), this._nodeIndexLOD = null, this._nodeSignalLODs = new Array(), this._nodePromiseLODs = new Array(), this._nodeBufferLODs = new Array(), this._materialIndexLOD = null, this._materialSignalLODs = new Array(), this._materialPromiseLODs = new Array(), this._materialBufferLODs = new Array(), this._loader = e4, this.enabled = this._loader.isExtensionUsed("MSFT_lod");
          }
          return e3.prototype.dispose = function() {
            this._loader = null, this._nodeIndexLOD = null, this._nodeSignalLODs.length = 0, this._nodePromiseLODs.length = 0, this._nodeBufferLODs.length = 0, this._materialIndexLOD = null, this._materialSignalLODs.length = 0, this._materialPromiseLODs.length = 0, this._materialBufferLODs.length = 0, this.onMaterialLODsLoadedObservable.clear(), this.onNodeLODsLoadedObservable.clear();
          }, e3.prototype.onReady = function() {
            for (var e4 = this, t2 = function(t3) {
              var r3 = Promise.all(n2._nodePromiseLODs[t3]).then(function() {
                t3 !== 0 && (e4._loader.endPerformanceCounter("Node LOD " + t3), e4._loader.log("Loaded node LOD " + t3)), e4.onNodeLODsLoadedObservable.notifyObservers(t3), t3 !== e4._nodePromiseLODs.length - 1 && (e4._loader.startPerformanceCounter("Node LOD " + (t3 + 1)), e4._loadBufferLOD(e4._nodeBufferLODs, t3 + 1), e4._nodeSignalLODs[t3] && e4._nodeSignalLODs[t3].resolve());
              });
              n2._loader._completePromises.push(r3);
            }, n2 = this, r2 = 0; r2 < this._nodePromiseLODs.length; r2++)
              t2(r2);
            var o2 = function(t3) {
              var n3 = Promise.all(a2._materialPromiseLODs[t3]).then(function() {
                t3 !== 0 && (e4._loader.endPerformanceCounter("Material LOD " + t3), e4._loader.log("Loaded material LOD " + t3)), e4.onMaterialLODsLoadedObservable.notifyObservers(t3), t3 !== e4._materialPromiseLODs.length - 1 && (e4._loader.startPerformanceCounter("Material LOD " + (t3 + 1)), e4._loadBufferLOD(e4._materialBufferLODs, t3 + 1), e4._materialSignalLODs[t3] && e4._materialSignalLODs[t3].resolve());
              });
              a2._loader._completePromises.push(n3);
            }, a2 = this;
            for (r2 = 0; r2 < this._materialPromiseLODs.length; r2++)
              o2(r2);
          }, e3.prototype.loadSceneAsync = function(e4, t2) {
            var n2 = this._loader.loadSceneAsync(e4, t2);
            return this._loadBufferLOD(this._bufferLODs, 0), n2;
          }, e3.prototype.loadNodeAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtensionAsync(e4, t2, this.name, function(e5, n3) {
              var o2, i2 = a2._getLODs(e5, t2, a2._loader.gltf.nodes, n3.ids);
              a2._loader.logOpen("" + e5);
              for (var s2 = function(e6) {
                var t3 = i2[e6];
                e6 !== 0 && (a2._nodeIndexLOD = e6, a2._nodeSignalLODs[e6] = a2._nodeSignalLODs[e6] || new r.Deferred());
                var n4 = a2._loader.loadNodeAsync("/nodes/" + t3.index, t3, function(e7) {
                  e7.setEnabled(false);
                }).then(function(t4) {
                  if (e6 !== 0) {
                    var n5 = i2[e6 - 1];
                    n5._babylonTransformNode && (a2._disposeTransformNode(n5._babylonTransformNode), delete n5._babylonTransformNode);
                  }
                  return t4.setEnabled(true), t4;
                });
                a2._nodePromiseLODs[e6] = a2._nodePromiseLODs[e6] || [], e6 === 0 ? o2 = n4 : (a2._nodeIndexLOD = null, a2._nodePromiseLODs[e6].push(n4));
              }, l2 = 0; l2 < i2.length; l2++)
                s2(l2);
              return a2._loader.logClose(), o2;
            });
          }, e3.prototype._loadMaterialAsync = function(e4, t2, n2, r2, a2) {
            var i2 = this;
            return this._nodeIndexLOD ? null : o.b.LoadExtensionAsync(e4, t2, this.name, function(e5, o2) {
              var s2, l2 = i2._getLODs(e5, t2, i2._loader.gltf.materials, o2.ids);
              i2._loader.logOpen("" + e5);
              for (var u2 = function(e6) {
                var t3 = l2[e6];
                e6 !== 0 && (i2._materialIndexLOD = e6);
                var o3 = i2._loader._loadMaterialAsync("/materials/" + t3.index, t3, n2, r2, function(t4) {
                  e6 === 0 && a2(t4);
                }).then(function(t4) {
                  if (e6 !== 0) {
                    a2(t4);
                    var n3 = l2[e6 - 1]._data;
                    n3[r2] && (i2._disposeMaterials([n3[r2].babylonMaterial]), delete n3[r2]);
                  }
                  return t4;
                });
                i2._materialPromiseLODs[e6] = i2._materialPromiseLODs[e6] || [], e6 === 0 ? s2 = o3 : (i2._materialIndexLOD = null, i2._materialPromiseLODs[e6].push(o3));
              }, c2 = 0; c2 < l2.length; c2++)
                u2(c2);
              return i2._loader.logClose(), s2;
            });
          }, e3.prototype._loadUriAsync = function(e4, t2, n2) {
            var o2 = this;
            if (this._nodeIndexLOD !== null) {
              this._loader.log("deferred");
              var a2 = this._nodeIndexLOD - 1;
              return this._nodeSignalLODs[a2] = this._nodeSignalLODs[a2] || new r.Deferred(), this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function() {
                return o2._loader.loadUriAsync(e4, t2, n2);
              });
            }
            if (this._materialIndexLOD !== null) {
              this._loader.log("deferred");
              a2 = this._materialIndexLOD - 1;
              return this._materialSignalLODs[a2] = this._materialSignalLODs[a2] || new r.Deferred(), this._materialSignalLODs[a2].promise.then(function() {
                return o2._loader.loadUriAsync(e4, t2, n2);
              });
            }
            return null;
          }, e3.prototype.loadBufferAsync = function(e4, t2, n2, o2) {
            if (this._loader.parent.useRangeRequests && !t2.uri) {
              if (!this._loader.bin)
                throw new Error(e4 + ": Uri is missing or the binary glTF is missing its binary chunk");
              var a2 = function(e5, t3) {
                var a3 = n2, i2 = a3 + o2 - 1, s2 = e5[t3];
                return s2 ? (s2.start = Math.min(s2.start, a3), s2.end = Math.max(s2.end, i2)) : (s2 = { start: a3, end: i2, loaded: new r.Deferred() }, e5[t3] = s2), s2.loaded.promise.then(function(e6) {
                  return new Uint8Array(e6.buffer, e6.byteOffset + n2 - s2.start, o2);
                });
              };
              return this._loader.log("deferred"), this._nodeIndexLOD !== null ? a2(this._nodeBufferLODs, this._nodeIndexLOD) : this._materialIndexLOD !== null ? a2(this._materialBufferLODs, this._materialIndexLOD) : a2(this._bufferLODs, 0);
            }
            return null;
          }, e3.prototype._loadBufferLOD = function(e4, t2) {
            var n2 = e4[t2];
            n2 && (this._loader.log("Loading buffer range [" + n2.start + "-" + n2.end + "]"), this._loader.bin.readAsync(n2.start, n2.end - n2.start + 1).then(function(e5) {
              n2.loaded.resolve(e5);
            }, function(e5) {
              n2.loaded.reject(e5);
            }));
          }, e3.prototype._getLODs = function(e4, t2, n2, r2) {
            if (this.maxLODsToLoad <= 0)
              throw new Error("maxLODsToLoad must be greater than zero");
            for (var a2 = new Array(), i2 = r2.length - 1; i2 >= 0; i2--)
              if (a2.push(o.a.Get(e4 + "/ids/" + r2[i2], n2, r2[i2])), a2.length === this.maxLODsToLoad)
                return a2;
            return a2.push(t2), a2;
          }, e3.prototype._disposeTransformNode = function(e4) {
            var t2 = this, n2 = new Array(), r2 = e4.material;
            r2 && n2.push(r2);
            for (var o2 = 0, a2 = e4.getChildMeshes(); o2 < a2.length; o2++) {
              var i2 = a2[o2];
              i2.material && n2.push(i2.material);
            }
            e4.dispose();
            var s2 = n2.filter(function(e5) {
              return t2._loader.babylonScene.meshes.every(function(t3) {
                return t3.material != e5;
              });
            });
            this._disposeMaterials(s2);
          }, e3.prototype._disposeMaterials = function(e4) {
            for (var t2 = {}, n2 = 0, r2 = e4; n2 < r2.length; n2++) {
              for (var o2 = 0, a2 = (c2 = r2[n2]).getActiveTextures(); o2 < a2.length; o2++) {
                var i2 = a2[o2];
                t2[i2.uniqueId] = i2;
              }
              c2.dispose();
            }
            for (var s2 in t2)
              for (var l2 = 0, u2 = this._loader.babylonScene.materials; l2 < u2.length; l2++) {
                var c2;
                (c2 = u2[l2]).hasTexture(t2[s2]) && delete t2[s2];
              }
            for (var s2 in t2)
              t2[s2].dispose();
          }, e3;
        }();
        o.b.RegisterExtension("MSFT_lod", function(e3) {
          return new O(e3);
        });
        var M = function() {
          function e3(e4) {
            this.name = "MSFT_minecraftMesh", this._loader = e4, this.enabled = this._loader.isExtensionUsed("MSFT_minecraftMesh");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtraAsync(e4, t2, this.name, function(o2, i2) {
              if (i2) {
                if (!(n2 instanceof r.PBRMaterial))
                  throw new Error(o2 + ": Material type not supported");
                var s2 = a2._loader.loadMaterialPropertiesAsync(e4, t2, n2);
                return n2.needAlphaBlending() && (n2.forceDepthWrite = true, n2.separateCullingPass = true), n2.backFaceCulling = n2.forceDepthWrite, n2.twoSidedLighting = true, s2;
              }
              return null;
            });
          }, e3;
        }();
        o.b.RegisterExtension("MSFT_minecraftMesh", function(e3) {
          return new M(e3);
        });
        var S = function() {
          function e3(e4) {
            this.name = "MSFT_sRGBFactors", this._loader = e4, this.enabled = this._loader.isExtensionUsed("MSFT_sRGBFactors");
          }
          return e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadMaterialPropertiesAsync = function(e4, t2, n2) {
            var a2 = this;
            return o.b.LoadExtraAsync(e4, t2, this.name, function(o2, i2) {
              if (i2) {
                if (!(n2 instanceof r.PBRMaterial))
                  throw new Error(o2 + ": Material type not supported");
                var s2 = a2._loader.loadMaterialPropertiesAsync(e4, t2, n2);
                return n2.albedoTexture || n2.albedoColor.toLinearSpaceToRef(n2.albedoColor), n2.reflectivityTexture || n2.reflectivityColor.toLinearSpaceToRef(n2.reflectivityColor), s2;
              }
              return null;
            });
          }, e3;
        }();
        o.b.RegisterExtension("MSFT_sRGBFactors", function(e3) {
          return new S(e3);
        });
        var w = function() {
          function e3(e4) {
            this.name = "ExtrasAsMetadata", this.enabled = true, this._loader = e4;
          }
          return e3.prototype._assignExtras = function(e4, t2) {
            if (t2.extras && Object.keys(t2.extras).length > 0) {
              var n2 = e4.metadata = e4.metadata || {};
              (n2.gltf = n2.gltf || {}).extras = t2.extras;
            }
          }, e3.prototype.dispose = function() {
            this._loader = null;
          }, e3.prototype.loadNodeAsync = function(e4, t2, n2) {
            var r2 = this;
            return this._loader.loadNodeAsync(e4, t2, function(e5) {
              r2._assignExtras(e5, t2), n2(e5);
            });
          }, e3.prototype.loadCameraAsync = function(e4, t2, n2) {
            var r2 = this;
            return this._loader.loadCameraAsync(e4, t2, function(e5) {
              r2._assignExtras(e5, t2), n2(e5);
            });
          }, e3.prototype.createMaterial = function(e4, t2, n2) {
            var r2 = this._loader.createMaterial(e4, t2, n2);
            return this._assignExtras(r2, t2), r2;
          }, e3;
        }();
        o.b.RegisterExtension("ExtrasAsMetadata", function(e3) {
          return new w(e3);
        });
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "GLTFBinaryExtension", function() {
          return k;
        }), n.d(t, "GLTFLoaderBase", function() {
          return D;
        }), n.d(t, "GLTFLoader", function() {
          return G;
        }), n.d(t, "GLTFLoaderExtension", function() {
          return U;
        }), n.d(t, "EComponentType", function() {
          return r;
        }), n.d(t, "EShaderType", function() {
          return o;
        }), n.d(t, "EParameterType", function() {
          return a;
        }), n.d(t, "ETextureWrapMode", function() {
          return i;
        }), n.d(t, "ETextureFilterType", function() {
          return s;
        }), n.d(t, "ETextureFormat", function() {
          return l;
        }), n.d(t, "ECullingType", function() {
          return u;
        }), n.d(t, "EBlendingFunction", function() {
          return c;
        }), n.d(t, "GLTFUtils", function() {
          return p;
        }), n.d(t, "GLTFMaterialsCommonExtension", function() {
          return H;
        });
        var r, o, a, i, s, l, u, c, d = n(4);
        !function(e3) {
          e3[e3.BYTE = 5120] = "BYTE", e3[e3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e3[e3.SHORT = 5122] = "SHORT", e3[e3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e3[e3.FLOAT = 5126] = "FLOAT";
        }(r || (r = {})), function(e3) {
          e3[e3.FRAGMENT = 35632] = "FRAGMENT", e3[e3.VERTEX = 35633] = "VERTEX";
        }(o || (o = {})), function(e3) {
          e3[e3.BYTE = 5120] = "BYTE", e3[e3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e3[e3.SHORT = 5122] = "SHORT", e3[e3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e3[e3.INT = 5124] = "INT", e3[e3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e3[e3.FLOAT = 5126] = "FLOAT", e3[e3.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", e3[e3.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", e3[e3.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", e3[e3.INT_VEC2 = 35667] = "INT_VEC2", e3[e3.INT_VEC3 = 35668] = "INT_VEC3", e3[e3.INT_VEC4 = 35669] = "INT_VEC4", e3[e3.BOOL = 35670] = "BOOL", e3[e3.BOOL_VEC2 = 35671] = "BOOL_VEC2", e3[e3.BOOL_VEC3 = 35672] = "BOOL_VEC3", e3[e3.BOOL_VEC4 = 35673] = "BOOL_VEC4", e3[e3.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", e3[e3.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", e3[e3.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", e3[e3.SAMPLER_2D = 35678] = "SAMPLER_2D";
        }(a || (a = {})), function(e3) {
          e3[e3.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", e3[e3.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e3[e3.REPEAT = 10497] = "REPEAT";
        }(i || (i = {})), function(e3) {
          e3[e3.NEAREST = 9728] = "NEAREST", e3[e3.LINEAR = 9728] = "LINEAR", e3[e3.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", e3[e3.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", e3[e3.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", e3[e3.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR";
        }(s || (s = {})), function(e3) {
          e3[e3.ALPHA = 6406] = "ALPHA", e3[e3.RGB = 6407] = "RGB", e3[e3.RGBA = 6408] = "RGBA", e3[e3.LUMINANCE = 6409] = "LUMINANCE", e3[e3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA";
        }(l || (l = {})), function(e3) {
          e3[e3.FRONT = 1028] = "FRONT", e3[e3.BACK = 1029] = "BACK", e3[e3.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK";
        }(u || (u = {})), function(e3) {
          e3[e3.ZERO = 0] = "ZERO", e3[e3.ONE = 1] = "ONE", e3[e3.SRC_COLOR = 768] = "SRC_COLOR", e3[e3.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", e3[e3.DST_COLOR = 774] = "DST_COLOR", e3[e3.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", e3[e3.SRC_ALPHA = 770] = "SRC_ALPHA", e3[e3.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", e3[e3.DST_ALPHA = 772] = "DST_ALPHA", e3[e3.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", e3[e3.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", e3[e3.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", e3[e3.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", e3[e3.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", e3[e3.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE";
        }(c || (c = {}));
        var f, h = n(0), p = function() {
          function e3() {
          }
          return e3.SetMatrix = function(e4, t2, n2, r2, o2) {
            var i2 = null;
            if (n2.semantic === "MODEL" ? i2 = t2.getWorldMatrix() : n2.semantic === "PROJECTION" ? i2 = e4.getProjectionMatrix() : n2.semantic === "VIEW" ? i2 = e4.getViewMatrix() : n2.semantic === "MODELVIEWINVERSETRANSPOSE" ? i2 = h.Matrix.Transpose(t2.getWorldMatrix().multiply(e4.getViewMatrix()).invert()) : n2.semantic === "MODELVIEW" ? i2 = t2.getWorldMatrix().multiply(e4.getViewMatrix()) : n2.semantic === "MODELVIEWPROJECTION" ? i2 = t2.getWorldMatrix().multiply(e4.getTransformMatrix()) : n2.semantic === "MODELINVERSE" ? i2 = t2.getWorldMatrix().invert() : n2.semantic === "VIEWINVERSE" ? i2 = e4.getViewMatrix().invert() : n2.semantic === "PROJECTIONINVERSE" ? i2 = e4.getProjectionMatrix().invert() : n2.semantic === "MODELVIEWINVERSE" ? i2 = t2.getWorldMatrix().multiply(e4.getViewMatrix()).invert() : n2.semantic === "MODELVIEWPROJECTIONINVERSE" ? i2 = t2.getWorldMatrix().multiply(e4.getTransformMatrix()).invert() : n2.semantic === "MODELINVERSETRANSPOSE" && (i2 = h.Matrix.Transpose(t2.getWorldMatrix().invert())), i2)
              switch (n2.type) {
                case a.FLOAT_MAT2:
                  o2.setMatrix2x2(r2, h.Matrix.GetAsMatrix2x2(i2));
                  break;
                case a.FLOAT_MAT3:
                  o2.setMatrix3x3(r2, h.Matrix.GetAsMatrix3x3(i2));
                  break;
                case a.FLOAT_MAT4:
                  o2.setMatrix(r2, i2);
              }
          }, e3.SetUniform = function(e4, t2, n2, r2) {
            switch (r2) {
              case a.FLOAT:
                return e4.setFloat(t2, n2), true;
              case a.FLOAT_VEC2:
                return e4.setVector2(t2, h.Vector2.FromArray(n2)), true;
              case a.FLOAT_VEC3:
                return e4.setVector3(t2, h.Vector3.FromArray(n2)), true;
              case a.FLOAT_VEC4:
                return e4.setVector4(t2, h.Vector4.FromArray(n2)), true;
              default:
                return false;
            }
          }, e3.GetWrapMode = function(e4) {
            switch (e4) {
              case i.CLAMP_TO_EDGE:
                return h.Texture.CLAMP_ADDRESSMODE;
              case i.MIRRORED_REPEAT:
                return h.Texture.MIRROR_ADDRESSMODE;
              case i.REPEAT:
              default:
                return h.Texture.WRAP_ADDRESSMODE;
            }
          }, e3.GetByteStrideFromType = function(e4) {
            switch (e4.type) {
              case "VEC2":
                return 2;
              case "VEC3":
                return 3;
              case "VEC4":
              case "MAT2":
                return 4;
              case "MAT3":
                return 9;
              case "MAT4":
                return 16;
              default:
                return 1;
            }
          }, e3.GetTextureFilterMode = function(e4) {
            switch (e4) {
              case s.LINEAR:
              case s.LINEAR_MIPMAP_NEAREST:
              case s.LINEAR_MIPMAP_LINEAR:
                return h.Texture.TRILINEAR_SAMPLINGMODE;
              case s.NEAREST:
              case s.NEAREST_MIPMAP_NEAREST:
                return h.Texture.NEAREST_SAMPLINGMODE;
              default:
                return h.Texture.BILINEAR_SAMPLINGMODE;
            }
          }, e3.GetBufferFromBufferView = function(e4, t2, n2, o2, a2) {
            n2 = t2.byteOffset + n2;
            var i2 = e4.loadedBufferViews[t2.buffer];
            if (n2 + o2 > i2.byteLength)
              throw new Error("Buffer access is out of range");
            var s2 = i2.buffer;
            switch (n2 += i2.byteOffset, a2) {
              case r.BYTE:
                return new Int8Array(s2, n2, o2);
              case r.UNSIGNED_BYTE:
                return new Uint8Array(s2, n2, o2);
              case r.SHORT:
                return new Int16Array(s2, n2, o2);
              case r.UNSIGNED_SHORT:
                return new Uint16Array(s2, n2, o2);
              default:
                return new Float32Array(s2, n2, o2);
            }
          }, e3.GetBufferFromAccessor = function(t2, n2) {
            var r2 = t2.bufferViews[n2.bufferView], o2 = n2.count * e3.GetByteStrideFromType(n2);
            return e3.GetBufferFromBufferView(t2, r2, n2.byteOffset, o2, n2.componentType);
          }, e3.DecodeBufferToText = function(e4) {
            for (var t2 = "", n2 = e4.byteLength, r2 = 0; r2 < n2; ++r2)
              t2 += String.fromCharCode(e4[r2]);
            return t2;
          }, e3.GetDefaultMaterial = function(t2) {
            if (!e3._DefaultMaterial) {
              h.Effect.ShadersStore.GLTFDefaultMaterialVertexShader = ["precision highp float;", "", "uniform mat4 worldView;", "uniform mat4 projection;", "", "attribute vec3 position;", "", "void main(void)", "{", "    gl_Position = projection * worldView * vec4(position, 1.0);", "}"].join("\n"), h.Effect.ShadersStore.GLTFDefaultMaterialPixelShader = ["precision highp float;", "", "uniform vec4 u_emission;", "", "void main(void)", "{", "    gl_FragColor = u_emission;", "}"].join("\n");
              var n2 = { attributes: ["position"], uniforms: ["worldView", "projection", "u_emission"], samplers: new Array(), needAlphaBlending: false };
              e3._DefaultMaterial = new h.ShaderMaterial("GLTFDefaultMaterial", t2, { vertex: "GLTFDefaultMaterial", fragment: "GLTFDefaultMaterial" }, n2), e3._DefaultMaterial.setColor4("u_emission", new h.Color4(0.5, 0.5, 0.5, 1));
            }
            return e3._DefaultMaterial;
          }, e3._DefaultMaterial = null, e3;
        }(), _ = n(2);
        !function(e3) {
          e3[e3.IDENTIFIER = 1] = "IDENTIFIER", e3[e3.UNKNOWN = 2] = "UNKNOWN", e3[e3.END_OF_INPUT = 3] = "END_OF_INPUT";
        }(f || (f = {}));
        var m = function() {
          function e3(e4) {
            this._pos = 0, this.currentToken = f.UNKNOWN, this.currentIdentifier = "", this.currentString = "", this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/, this._toParse = e4, this._maxPos = e4.length;
          }
          return e3.prototype.getNextToken = function() {
            if (this.isEnd())
              return f.END_OF_INPUT;
            if (this.currentString = this.read(), this.currentToken = f.UNKNOWN, this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString))
              for (this.currentToken = f.IDENTIFIER, this.currentIdentifier = this.currentString; !this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_"); )
                this.currentIdentifier += this.currentString, this.forward();
            return this.currentToken;
          }, e3.prototype.peek = function() {
            return this._toParse[this._pos];
          }, e3.prototype.read = function() {
            return this._toParse[this._pos++];
          }, e3.prototype.forward = function() {
            this._pos++;
          }, e3.prototype.isEnd = function() {
            return this._pos >= this._maxPos;
          }, e3;
        }(), y = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"], b = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"], v = ["translation", "rotation", "scale"], g = ["position", "rotationQuaternion", "scaling"], A = function(e3, t2, n2) {
          for (var r2 in e3) {
            var o2 = e3[r2];
            n2[t2][r2] = o2;
          }
        }, T = function(e3) {
          if (e3)
            for (var t2 = 0; t2 < e3.length / 2; t2++)
              e3[2 * t2 + 1] = 1 - e3[2 * t2 + 1];
        }, x = function(e3) {
          if (e3.semantic === "NORMAL")
            return "normal";
          if (e3.semantic === "POSITION")
            return "position";
          if (e3.semantic === "JOINT")
            return "matricesIndices";
          if (e3.semantic === "WEIGHT")
            return "matricesWeights";
          if (e3.semantic === "COLOR")
            return "color";
          if (e3.semantic && e3.semantic.indexOf("TEXCOORD_") !== -1) {
            var t2 = Number(e3.semantic.split("_")[1]);
            return "uv" + (t2 === 0 ? "" : t2 + 1);
          }
          return null;
        }, E = function(e3) {
          var t2 = null;
          if (e3.translation || e3.rotation || e3.scale) {
            var n2 = h.Vector3.FromArray(e3.scale || [1, 1, 1]), r2 = h.Quaternion.FromArray(e3.rotation || [0, 0, 0, 1]), o2 = h.Vector3.FromArray(e3.translation || [0, 0, 0]);
            t2 = h.Matrix.Compose(n2, r2, o2);
          } else
            t2 = h.Matrix.FromArray(e3.matrix);
          return t2;
        }, L = function(e3, t2, n2, r2) {
          for (var o2 = 0; o2 < r2.bones.length; o2++)
            if (r2.bones[o2].name === n2)
              return r2.bones[o2];
          var a2 = e3.nodes;
          for (var i2 in a2) {
            var s2 = a2[i2];
            if (s2.jointName) {
              var l2 = s2.children;
              for (o2 = 0; o2 < l2.length; o2++) {
                var u2 = e3.nodes[l2[o2]];
                if (u2.jointName && u2.jointName === n2) {
                  var c2 = E(s2), d2 = new h.Bone(s2.name || "", r2, L(e3, t2, s2.jointName, r2), c2);
                  return d2.id = i2, d2;
                }
              }
            }
          }
          return null;
        }, O = function(e3, t2) {
          for (var n2 = 0; n2 < e3.length; n2++)
            for (var r2 = e3[n2], o2 = 0; o2 < r2.node.children.length; o2++) {
              if (r2.node.children[o2] === t2)
                return r2.bone;
            }
          return null;
        }, M = function(e3, t2) {
          var n2 = e3.nodes, r2 = n2[t2];
          if (r2)
            return { node: r2, id: t2 };
          for (var o2 in n2)
            if ((r2 = n2[o2]).jointName === t2)
              return { node: r2, id: o2 };
          return null;
        }, S = function(e3, t2) {
          for (var n2 = 0; n2 < e3.jointNames.length; n2++)
            if (e3.jointNames[n2] === t2)
              return true;
          return false;
        }, w = function(e3, t2, n2, r2, o2) {
          if (r2 || (r2 = new h.Skeleton(t2.name || "", "", e3.scene)), !t2.babylonSkeleton)
            return r2;
          var a2 = [], i2 = [];
          !function(e4, t3, n3, r3) {
            for (var o3 in e4.nodes) {
              var a3 = e4.nodes[o3], i3 = o3;
              if (a3.jointName && !S(n3, a3.jointName)) {
                var s3 = E(a3), l3 = new h.Bone(a3.name || "", t3, null, s3);
                l3.id = i3, r3.push({ bone: l3, node: a3, id: i3 });
              }
            }
            for (var u3 = 0; u3 < r3.length; u3++)
              for (var c3 = r3[u3], d3 = c3.node.children, f3 = 0; f3 < d3.length; f3++) {
                for (var p3 = null, _3 = 0; _3 < r3.length; _3++)
                  if (r3[_3].id === d3[f3]) {
                    p3 = r3[_3];
                    break;
                  }
                p3 && (p3.bone._parent = c3.bone, c3.bone.children.push(p3.bone));
              }
          }(e3, r2, t2, a2), r2.bones = [];
          for (var s2 = 0; s2 < t2.jointNames.length; s2++) {
            if (g2 = M(e3, t2.jointNames[s2])) {
              var l2 = g2.node;
              if (l2) {
                o2 = g2.id;
                var u2 = e3.scene.getBoneByID(o2);
                if (u2)
                  r2.bones.push(u2);
                else {
                  for (var c2 = false, d2 = null, f2 = 0; f2 < s2; f2++) {
                    var p2 = M(e3, t2.jointNames[f2]);
                    if (p2) {
                      var _2 = p2.node;
                      if (_2) {
                        var m2 = _2.children;
                        if (m2) {
                          c2 = false;
                          for (var y2 = 0; y2 < m2.length; y2++)
                            if (m2[y2] === o2) {
                              d2 = L(e3, t2, t2.jointNames[f2], r2), c2 = true;
                              break;
                            }
                          if (c2)
                            break;
                        }
                      } else
                        h.Tools.Warn("Joint named " + t2.jointNames[f2] + " does not exist when looking for parent");
                    }
                  }
                  var b2 = E(l2);
                  !d2 && a2.length > 0 && (d2 = O(a2, o2)) && i2.indexOf(d2) === -1 && i2.push(d2), new h.Bone(l2.jointName || "", r2, d2, b2).id = o2;
                }
              } else
                h.Tools.Warn("Joint named " + t2.jointNames[s2] + " does not exist");
            }
          }
          var v2 = r2.bones;
          r2.bones = [];
          for (s2 = 0; s2 < t2.jointNames.length; s2++) {
            var g2;
            if (g2 = M(e3, t2.jointNames[s2])) {
              for (f2 = 0; f2 < v2.length; f2++)
                if (v2[f2].id === g2.id) {
                  r2.bones.push(v2[f2]);
                  break;
                }
            }
          }
          r2.prepare();
          for (s2 = 0; s2 < i2.length; s2++)
            r2.bones.push(i2[s2]);
          return r2;
        }, R = function(e3, t2, n2, r2, o2) {
          if (o2 || (e3.scene._blockEntityCollection = e3.forAssetContainer, o2 = new h.Mesh(t2.name || "", e3.scene), e3.scene._blockEntityCollection = false, o2.id = r2), !t2.babylonNode)
            return o2;
          for (var a2, i2 = [], s2 = null, l2 = new Array(), u2 = new Array(), c2 = new Array(), d2 = new Array(), f2 = 0; f2 < n2.length; f2++) {
            var m2 = n2[f2];
            if (N2 = e3.meshes[m2])
              for (var y2 = 0; y2 < N2.primitives.length; y2++) {
                var b2 = new h.VertexData(), v2 = N2.primitives[y2];
                v2.mode;
                var g2 = v2.attributes, A2 = null, x2 = null;
                for (var E2 in g2)
                  if (A2 = e3.accessors[g2[E2]], x2 = p.GetBufferFromAccessor(e3, A2), E2 === "NORMAL")
                    b2.normals = new Float32Array(x2.length), b2.normals.set(x2);
                  else if (E2 === "POSITION") {
                    if (_.GLTFFileLoader.HomogeneousCoordinates) {
                      b2.positions = new Float32Array(x2.length - x2.length / 4);
                      for (var L2 = 0; L2 < x2.length; L2 += 4)
                        b2.positions[L2] = x2[L2], b2.positions[L2 + 1] = x2[L2 + 1], b2.positions[L2 + 2] = x2[L2 + 2];
                    } else
                      b2.positions = new Float32Array(x2.length), b2.positions.set(x2);
                    u2.push(b2.positions.length);
                  } else if (E2.indexOf("TEXCOORD_") !== -1) {
                    var O2 = Number(E2.split("_")[1]), M2 = h.VertexBuffer.UVKind + (O2 === 0 ? "" : O2 + 1), S2 = new Float32Array(x2.length);
                    S2.set(x2), T(S2), b2.set(S2, M2);
                  } else
                    E2 === "JOINT" ? (b2.matricesIndices = new Float32Array(x2.length), b2.matricesIndices.set(x2)) : E2 === "WEIGHT" ? (b2.matricesWeights = new Float32Array(x2.length), b2.matricesWeights.set(x2)) : E2 === "COLOR" && (b2.colors = new Float32Array(x2.length), b2.colors.set(x2));
                if (A2 = e3.accessors[v2.indices])
                  x2 = p.GetBufferFromAccessor(e3, A2), b2.indices = new Int32Array(x2.length), b2.indices.set(x2), d2.push(b2.indices.length);
                else {
                  var w2 = [];
                  for (L2 = 0; L2 < b2.positions.length / 3; L2++)
                    w2.push(L2);
                  b2.indices = new Int32Array(w2), d2.push(b2.indices.length);
                }
                s2 ? s2.merge(b2) : s2 = b2;
                var R2 = e3.scene.getMaterialByID(v2.material);
                i2.push(R2 === null ? p.GetDefaultMaterial(e3.scene) : R2), l2.push(l2.length === 0 ? 0 : l2[l2.length - 1] + u2[u2.length - 2]), c2.push(c2.length === 0 ? 0 : c2[c2.length - 1] + d2[d2.length - 2]);
              }
          }
          e3.scene._blockEntityCollection = e3.forAssetContainer, i2.length > 1 ? (a2 = new h.MultiMaterial("multimat" + r2, e3.scene)).subMaterials = i2 : a2 = new h.StandardMaterial("multimat" + r2, e3.scene), i2.length === 1 && (a2 = i2[0]), o2.material || (o2.material = a2), new h.Geometry(r2, e3.scene, s2, false, o2), o2.computeWorldMatrix(true), e3.scene._blockEntityCollection = false, o2.subMeshes = [];
          var C2 = 0;
          for (f2 = 0; f2 < n2.length; f2++) {
            var N2;
            m2 = n2[f2];
            if (N2 = e3.meshes[m2])
              for (y2 = 0; y2 < N2.primitives.length; y2++)
                N2.primitives[y2].mode, h.SubMesh.AddToMesh(C2, l2[C2], u2[C2], c2[C2], d2[C2], o2, o2, true), C2++;
          }
          return o2;
        }, C = function(e3, t2, n2, r2) {
          e3.position && (e3.position = t2), (e3.rotationQuaternion || e3.rotation) && (e3.rotationQuaternion = n2), e3.scaling && (e3.scaling = r2);
        }, N = function(e3, t2, n2, r2) {
          var o2 = null;
          if (e3.importOnlyMeshes && (t2.skin || t2.meshes) && e3.importMeshesNames && e3.importMeshesNames.length > 0 && e3.importMeshesNames.indexOf(t2.name || "") === -1)
            return null;
          if (t2.skin) {
            if (t2.meshes) {
              var a2 = e3.skins[t2.skin];
              (i2 = R(e3, t2, t2.meshes, n2, t2.babylonNode)).skeleton = e3.scene.getLastSkeletonByID(t2.skin), i2.skeleton === null && (i2.skeleton = w(e3, a2, 0, a2.babylonSkeleton, t2.skin), a2.babylonSkeleton || (a2.babylonSkeleton = i2.skeleton)), o2 = i2;
            }
          } else if (t2.meshes) {
            var i2;
            o2 = i2 = R(e3, t2, t2.mesh ? [t2.mesh] : t2.meshes, n2, t2.babylonNode);
          } else if (!t2.light || t2.babylonNode || e3.importOnlyMeshes) {
            if (t2.camera && !t2.babylonNode && !e3.importOnlyMeshes) {
              var s2 = e3.cameras[t2.camera];
              if (s2) {
                if (e3.scene._blockEntityCollection = e3.forAssetContainer, s2.type === "orthographic") {
                  var l2 = new h.FreeCamera(t2.camera, h.Vector3.Zero(), e3.scene, false);
                  l2.name = t2.name || "", l2.mode = h.Camera.ORTHOGRAPHIC_CAMERA, l2.attachControl(), o2 = l2;
                } else if (s2.type === "perspective") {
                  var u2 = s2[s2.type], c2 = new h.FreeCamera(t2.camera, h.Vector3.Zero(), e3.scene, false);
                  c2.name = t2.name || "", c2.attachControl(), u2.aspectRatio || (u2.aspectRatio = e3.scene.getEngine().getRenderWidth() / e3.scene.getEngine().getRenderHeight()), u2.znear && u2.zfar && (c2.maxZ = u2.zfar, c2.minZ = u2.znear), o2 = c2;
                }
                e3.scene._blockEntityCollection = false;
              }
            }
          } else {
            var d2 = e3.lights[t2.light];
            if (d2) {
              if (d2.type === "ambient") {
                var f2 = d2[d2.type], p2 = new h.HemisphericLight(t2.light, h.Vector3.Zero(), e3.scene);
                p2.name = t2.name || "", f2.color && (p2.diffuse = h.Color3.FromArray(f2.color)), o2 = p2;
              } else if (d2.type === "directional") {
                var _2 = d2[d2.type], m2 = new h.DirectionalLight(t2.light, h.Vector3.Zero(), e3.scene);
                m2.name = t2.name || "", _2.color && (m2.diffuse = h.Color3.FromArray(_2.color)), o2 = m2;
              } else if (d2.type === "point") {
                var y2 = d2[d2.type], b2 = new h.PointLight(t2.light, h.Vector3.Zero(), e3.scene);
                b2.name = t2.name || "", y2.color && (b2.diffuse = h.Color3.FromArray(y2.color)), o2 = b2;
              } else if (d2.type === "spot") {
                var v2 = d2[d2.type], g2 = new h.SpotLight(t2.light, h.Vector3.Zero(), h.Vector3.Zero(), 0, 0, e3.scene);
                g2.name = t2.name || "", v2.color && (g2.diffuse = h.Color3.FromArray(v2.color)), v2.fallOfAngle && (g2.angle = v2.fallOfAngle), v2.fallOffExponent && (g2.exponent = v2.fallOffExponent), o2 = g2;
              }
            }
          }
          if (!t2.jointName) {
            if (t2.babylonNode)
              return t2.babylonNode;
            if (o2 === null) {
              e3.scene._blockEntityCollection = e3.forAssetContainer;
              var A2 = new h.Mesh(t2.name || "", e3.scene);
              e3.scene._blockEntityCollection = false, t2.babylonNode = A2, o2 = A2;
            }
          }
          if (o2 !== null) {
            if (t2.matrix && o2 instanceof h.Mesh)
              !function(e4, t3, n3) {
                if (t3.matrix) {
                  var r3 = new h.Vector3(0, 0, 0), o3 = new h.Quaternion(), a3 = new h.Vector3(0, 0, 0);
                  h.Matrix.FromArray(t3.matrix).decompose(a3, o3, r3), C(e4, r3, o3, a3);
                } else
                  t3.translation && t3.rotation && t3.scale && C(e4, h.Vector3.FromArray(t3.translation), h.Quaternion.FromArray(t3.rotation), h.Vector3.FromArray(t3.scale));
                e4.computeWorldMatrix(true);
              }(o2, t2);
            else {
              var T2 = t2.translation || [0, 0, 0], x2 = t2.rotation || [0, 0, 0, 1], E2 = t2.scale || [1, 1, 1];
              C(o2, h.Vector3.FromArray(T2), h.Quaternion.FromArray(x2), h.Vector3.FromArray(E2));
            }
            o2.updateCache(true), t2.babylonNode = o2;
          }
          return o2;
        }, P = function(e3, t2, n2, r2) {
          r2 === void 0 && (r2 = false);
          var o2 = e3.nodes[t2], a2 = null;
          if (r2 = !(e3.importOnlyMeshes && !r2 && e3.importMeshesNames) || (e3.importMeshesNames.indexOf(o2.name || "") !== -1 || e3.importMeshesNames.length === 0), !o2.jointName && r2 && (a2 = N(e3, o2, t2)) !== null && (a2.id = t2, a2.parent = n2), o2.children)
            for (var i2 = 0; i2 < o2.children.length; i2++)
              P(e3, o2.children[i2], a2, r2);
        }, I = function(e3) {
          var t2 = e3.currentScene;
          if (t2)
            for (var n2 = 0; n2 < t2.nodes.length; n2++)
              P(e3, t2.nodes[n2], null);
          else
            for (var r2 in e3.scenes) {
              t2 = e3.scenes[r2];
              for (n2 = 0; n2 < t2.nodes.length; n2++)
                P(e3, t2.nodes[n2], null);
            }
          !function(e4) {
            for (var t3 in e4.animations) {
              var n3 = e4.animations[t3];
              if (n3.channels && n3.samplers)
                for (var r3 = null, o3 = 0; o3 < n3.channels.length; o3++) {
                  var a2 = n3.channels[o3], i2 = n3.samplers[a2.sampler];
                  if (i2) {
                    var s2 = null, l2 = null;
                    n3.parameters ? (s2 = n3.parameters[i2.input], l2 = n3.parameters[i2.output]) : (s2 = i2.input, l2 = i2.output);
                    var u2 = p.GetBufferFromAccessor(e4, e4.accessors[s2]), c2 = p.GetBufferFromAccessor(e4, e4.accessors[l2]), d2 = a2.target.id, f2 = e4.scene.getNodeByID(d2);
                    if (f2 === null && (f2 = e4.scene.getNodeByName(d2)), f2 !== null) {
                      var _2 = f2 instanceof h.Bone, m2 = a2.target.path, y2 = v.indexOf(m2);
                      y2 !== -1 && (m2 = g[y2]);
                      var b2 = h.Animation.ANIMATIONTYPE_MATRIX;
                      _2 || (m2 === "rotationQuaternion" ? (b2 = h.Animation.ANIMATIONTYPE_QUATERNION, f2.rotationQuaternion = new h.Quaternion()) : b2 = h.Animation.ANIMATIONTYPE_VECTOR3);
                      var A2 = null, T2 = [], x2 = 0, E2 = false;
                      _2 && r3 && r3.getKeys().length === u2.length && (A2 = r3, E2 = true), E2 || (e4.scene._blockEntityCollection = e4.forAssetContainer, A2 = new h.Animation(t3, _2 ? "_matrix" : m2, 1, b2, h.Animation.ANIMATIONLOOPMODE_CYCLE), e4.scene._blockEntityCollection = false);
                      for (var L2 = 0; L2 < u2.length; L2++) {
                        var O2 = null;
                        if (m2 === "rotationQuaternion" ? (O2 = h.Quaternion.FromArray([c2[x2], c2[x2 + 1], c2[x2 + 2], c2[x2 + 3]]), x2 += 4) : (O2 = h.Vector3.FromArray([c2[x2], c2[x2 + 1], c2[x2 + 2]]), x2 += 3), _2) {
                          var M2 = f2, S2 = h.Vector3.Zero(), w2 = new h.Quaternion(), R2 = h.Vector3.Zero(), C2 = M2.getBaseMatrix();
                          E2 && r3 && (C2 = r3.getKeys()[L2].value), C2.decompose(R2, w2, S2), m2 === "position" ? S2 = O2 : m2 === "rotationQuaternion" ? w2 = O2 : R2 = O2, O2 = h.Matrix.Compose(R2, w2, S2);
                        }
                        E2 ? r3 && (r3.getKeys()[L2].value = O2) : T2.push({ frame: u2[L2], value: O2 });
                      }
                      !E2 && A2 && (A2.setKeys(T2), f2.animations.push(A2)), r3 = A2, e4.scene.stopAnimation(f2), e4.scene.beginAnimation(f2, 0, u2[u2.length - 1], true, 1);
                    } else
                      h.Tools.Warn("Creating animation named " + t3 + ". But cannot find node named " + d2 + " to attach to");
                  }
                }
            }
          }(e3);
          for (n2 = 0; n2 < e3.scene.skeletons.length; n2++) {
            var o2 = e3.scene.skeletons[n2];
            e3.scene.beginAnimation(o2, 0, Number.MAX_VALUE, true, 1);
          }
        }, F = function(e3, t2, n2, r2, o2, i2) {
          return function(s2) {
            !function(e4, t3, n3, r3, o3) {
              var i3 = r3.values || n3.parameters, s3 = n3.uniforms;
              for (var l2 in o3) {
                var u2 = o3[l2], c2 = u2.type, d2 = i3[s3[l2]];
                if (d2 === void 0 && (d2 = u2.value), d2) {
                  var f2 = function(e5) {
                    return function(n4) {
                      u2.value && e5 && (t3.setTexture(e5, n4), delete o3[e5]);
                    };
                  };
                  c2 === a.SAMPLER_2D ? U.LoadTextureAsync(e4, r3.values ? d2 : u2.value, f2(l2), function() {
                    return f2(null);
                  }) : u2.value && p.SetUniform(t3, l2, r3.values ? d2 : u2.value, c2) && delete o3[l2];
                }
              }
            }(e3, t2, n2, r2, o2), t2.onBind = function(s3) {
              !function(e4, t3, n3, r3, o3, i3, s4) {
                var l2 = i3.values || o3.parameters;
                for (var u2 in n3) {
                  var c2 = n3[u2], d2 = c2.type;
                  if (d2 === a.FLOAT_MAT2 || d2 === a.FLOAT_MAT3 || d2 === a.FLOAT_MAT4)
                    if (!c2.semantic || c2.source || c2.node) {
                      if (c2.semantic && (c2.source || c2.node)) {
                        var f2 = t3.scene.getNodeByName(c2.source || c2.node || "");
                        if (f2 === null && (f2 = t3.scene.getNodeByID(c2.source || c2.node || "")), f2 === null)
                          continue;
                        p.SetMatrix(t3.scene, f2, c2, u2, r3.getEffect());
                      }
                    } else
                      p.SetMatrix(t3.scene, e4, c2, u2, r3.getEffect());
                  else {
                    var h2 = l2[o3.uniforms[u2]];
                    if (!h2)
                      continue;
                    if (d2 === a.SAMPLER_2D) {
                      var _2 = t3.textures[i3.values ? h2 : c2.value].babylonTexture;
                      if (_2 == null)
                        continue;
                      r3.getEffect().setTexture(u2, _2);
                    } else
                      p.SetUniform(r3.getEffect(), u2, h2, d2);
                  }
                }
                s4(r3);
              }(s3, e3, o2, t2, n2, r2, i2);
            };
          };
        }, B = function(e3, t2, n2) {
          for (var r2 in t2.uniforms) {
            var o2 = t2.uniforms[r2], a2 = t2.parameters[o2];
            if (e3.currentIdentifier === r2 && a2.semantic && !a2.source && !a2.node) {
              var i2 = y.indexOf(a2.semantic);
              if (i2 !== -1)
                return delete n2[r2], b[i2];
            }
          }
          return e3.currentIdentifier;
        }, V = function(e3) {
          for (var t2 in e3.materials)
            U.LoadMaterialAsync(e3, t2, function(e4) {
            }, function() {
            });
        }, D = function() {
          function e3() {
          }
          return e3.CreateRuntime = function(e4, t2, n2) {
            var r2 = { extensions: {}, accessors: {}, buffers: {}, bufferViews: {}, meshes: {}, lights: {}, cameras: {}, nodes: {}, images: {}, textures: {}, shaders: {}, programs: {}, samplers: {}, techniques: {}, materials: {}, animations: {}, skins: {}, extensionsUsed: [], scenes: {}, buffersCount: 0, shaderscount: 0, scene: t2, rootUrl: n2, loadedBufferCount: 0, loadedBufferViews: {}, loadedShaderCount: 0, importOnlyMeshes: false, dummyNodes: [], forAssetContainer: false };
            return e4.extensions && A(e4.extensions, "extensions", r2), e4.extensionsUsed && A(e4.extensionsUsed, "extensionsUsed", r2), e4.buffers && function(e5, t3) {
              for (var n3 in e5) {
                var r3 = e5[n3];
                t3.buffers[n3] = r3, t3.buffersCount++;
              }
            }(e4.buffers, r2), e4.bufferViews && A(e4.bufferViews, "bufferViews", r2), e4.accessors && A(e4.accessors, "accessors", r2), e4.meshes && A(e4.meshes, "meshes", r2), e4.lights && A(e4.lights, "lights", r2), e4.cameras && A(e4.cameras, "cameras", r2), e4.nodes && A(e4.nodes, "nodes", r2), e4.images && A(e4.images, "images", r2), e4.textures && A(e4.textures, "textures", r2), e4.shaders && function(e5, t3) {
              for (var n3 in e5) {
                var r3 = e5[n3];
                t3.shaders[n3] = r3, t3.shaderscount++;
              }
            }(e4.shaders, r2), e4.programs && A(e4.programs, "programs", r2), e4.samplers && A(e4.samplers, "samplers", r2), e4.techniques && A(e4.techniques, "techniques", r2), e4.materials && A(e4.materials, "materials", r2), e4.animations && A(e4.animations, "animations", r2), e4.skins && A(e4.skins, "skins", r2), e4.scenes && (r2.scenes = e4.scenes), e4.scene && e4.scenes && (r2.currentScene = e4.scenes[e4.scene]), r2;
          }, e3.LoadBufferAsync = function(e4, t2, n2, r2, o2) {
            var a2 = e4.buffers[t2];
            h.Tools.IsBase64(a2.uri) ? setTimeout(function() {
              return n2(new Uint8Array(h.Tools.DecodeBase64(a2.uri)));
            }) : h.Tools.LoadFile(e4.rootUrl + a2.uri, function(e5) {
              return n2(new Uint8Array(e5));
            }, o2, void 0, true, function(e5) {
              e5 && r2(e5.status + " " + e5.statusText);
            });
          }, e3.LoadTextureBufferAsync = function(e4, t2, n2, r2) {
            var o2 = e4.textures[t2];
            if (o2 && o2.source)
              if (o2.babylonTexture)
                n2(null);
              else {
                var a2 = e4.images[o2.source];
                h.Tools.IsBase64(a2.uri) ? setTimeout(function() {
                  return n2(new Uint8Array(h.Tools.DecodeBase64(a2.uri)));
                }) : h.Tools.LoadFile(e4.rootUrl + a2.uri, function(e5) {
                  return n2(new Uint8Array(e5));
                }, void 0, void 0, true, function(e5) {
                  e5 && r2(e5.status + " " + e5.statusText);
                });
              }
            else
              r2("");
          }, e3.CreateTextureAsync = function(e4, t2, n2, r2, o2) {
            var a2 = e4.textures[t2];
            if (a2.babylonTexture)
              r2(a2.babylonTexture);
            else {
              var i2 = e4.samplers[a2.sampler], l2 = i2.minFilter === s.NEAREST_MIPMAP_NEAREST || i2.minFilter === s.NEAREST_MIPMAP_LINEAR || i2.minFilter === s.LINEAR_MIPMAP_NEAREST || i2.minFilter === s.LINEAR_MIPMAP_LINEAR, u2 = h.Texture.BILINEAR_SAMPLINGMODE, c2 = n2 == null ? new Blob() : new Blob([n2]), d2 = URL.createObjectURL(c2), f2 = function() {
                return URL.revokeObjectURL(d2);
              }, _2 = new h.Texture(d2, e4.scene, !l2, true, u2, f2, f2);
              i2.wrapS !== void 0 && (_2.wrapU = p.GetWrapMode(i2.wrapS)), i2.wrapT !== void 0 && (_2.wrapV = p.GetWrapMode(i2.wrapT)), _2.name = t2, a2.babylonTexture = _2, r2(_2);
            }
          }, e3.LoadShaderStringAsync = function(e4, t2, n2, r2) {
            var o2 = e4.shaders[t2];
            if (h.Tools.IsBase64(o2.uri)) {
              var a2 = atob(o2.uri.split(",")[1]);
              n2 && n2(a2);
            } else
              h.Tools.LoadFile(e4.rootUrl + o2.uri, n2, void 0, void 0, false, function(e5) {
                e5 && r2 && r2(e5.status + " " + e5.statusText);
              });
          }, e3.LoadMaterialAsync = function(e4, t2, n2, r2) {
            var o2 = e4.materials[t2];
            if (o2.technique) {
              var i2 = e4.techniques[o2.technique];
              if (!i2) {
                e4.scene._blockEntityCollection = e4.forAssetContainer;
                var s2 = new h.StandardMaterial(t2, e4.scene);
                return e4.scene._blockEntityCollection = false, s2.diffuseColor = new h.Color3(0.5, 0.5, 0.5), s2.sideOrientation = h.Material.CounterClockWiseSideOrientation, void n2(s2);
              }
              var l2 = e4.programs[i2.program], d2 = i2.states, p2 = h.Effect.ShadersStore[l2.vertexShader + "VertexShader"], _2 = h.Effect.ShadersStore[l2.fragmentShader + "PixelShader"], v2 = "", g2 = "", A2 = new m(p2), T2 = new m(_2), E2 = {}, L2 = [], O2 = [], M2 = [];
              for (var S2 in i2.uniforms) {
                var w2 = i2.uniforms[S2], R2 = i2.parameters[w2];
                if (E2[S2] = R2, !R2.semantic || R2.node || R2.source)
                  R2.type === a.SAMPLER_2D ? M2.push(S2) : L2.push(S2);
                else {
                  var C2 = y.indexOf(R2.semantic);
                  C2 !== -1 ? (L2.push(b[C2]), delete E2[S2]) : L2.push(S2);
                }
              }
              for (var N2 in i2.attributes) {
                var P2 = i2.attributes[N2];
                if ((D2 = i2.parameters[P2]).semantic) {
                  var I2 = x(D2);
                  I2 && O2.push(I2);
                }
              }
              for (; !A2.isEnd() && A2.getNextToken(); ) {
                if (A2.currentToken === f.IDENTIFIER) {
                  var V2 = false;
                  for (var N2 in i2.attributes) {
                    P2 = i2.attributes[N2];
                    var D2 = i2.parameters[P2];
                    if (A2.currentIdentifier === N2 && D2.semantic) {
                      v2 += x(D2), V2 = true;
                      break;
                    }
                  }
                  V2 || (v2 += B(A2, i2, E2));
                } else
                  v2 += A2.currentString;
              }
              for (; !T2.isEnd() && T2.getNextToken(); ) {
                T2.currentToken === f.IDENTIFIER ? g2 += B(T2, i2, E2) : g2 += T2.currentString;
              }
              var G2 = { vertex: l2.vertexShader + t2, fragment: l2.fragmentShader + t2 }, U2 = { attributes: O2, uniforms: L2, samplers: M2, needAlphaBlending: d2 && d2.enable && d2.enable.indexOf(3042) !== -1 };
              h.Effect.ShadersStore[l2.vertexShader + t2 + "VertexShader"] = v2, h.Effect.ShadersStore[l2.fragmentShader + t2 + "PixelShader"] = g2;
              var k2 = new h.ShaderMaterial(t2, e4.scene, G2, U2);
              if (k2.onError = function(e5, t3, n3) {
                return function(r3, o3) {
                  t3.dispose(true), n3("Cannot compile program named " + e5.name + ". Error: " + o3 + ". Default material will be applied");
                };
              }(l2, k2, r2), k2.onCompiled = F(e4, k2, i2, o2, E2, n2), k2.sideOrientation = h.Material.CounterClockWiseSideOrientation, d2 && d2.functions) {
                var H2 = d2.functions;
                H2.cullFace && H2.cullFace[0] !== u.BACK && (k2.backFaceCulling = false);
                var K = H2.blendFuncSeparate;
                K && (K[0] === c.SRC_ALPHA && K[1] === c.ONE_MINUS_SRC_ALPHA && K[2] === c.ONE && K[3] === c.ONE ? k2.alphaMode = h.Constants.ALPHA_COMBINE : K[0] === c.ONE && K[1] === c.ONE && K[2] === c.ZERO && K[3] === c.ONE ? k2.alphaMode = h.Constants.ALPHA_ONEONE : K[0] === c.SRC_ALPHA && K[1] === c.ONE && K[2] === c.ZERO && K[3] === c.ONE ? k2.alphaMode = h.Constants.ALPHA_ADD : K[0] === c.ZERO && K[1] === c.ONE_MINUS_SRC_COLOR && K[2] === c.ONE && K[3] === c.ONE ? k2.alphaMode = h.Constants.ALPHA_SUBTRACT : K[0] === c.DST_COLOR && K[1] === c.ZERO && K[2] === c.ONE && K[3] === c.ONE ? k2.alphaMode = h.Constants.ALPHA_MULTIPLY : K[0] === c.SRC_ALPHA && K[1] === c.ONE_MINUS_SRC_COLOR && K[2] === c.ONE && K[3] === c.ONE && (k2.alphaMode = h.Constants.ALPHA_MAXIMIZED));
              }
            } else
              r2 && r2("No technique found.");
          }, e3;
        }(), G = function() {
          function e3() {
            this.state = null;
          }
          return e3.RegisterExtension = function(t2) {
            e3.Extensions[t2.name] ? h.Tools.Error('Tool with the same name "' + t2.name + '" already exists') : e3.Extensions[t2.name] = t2;
          }, e3.prototype.dispose = function() {
          }, e3.prototype._importMeshAsync = function(e4, t2, n2, r2, o2, a2, i2, s2) {
            var l2 = this;
            return t2.useRightHandedSystem = true, U.LoadRuntimeAsync(t2, n2, r2, function(t3) {
              t3.forAssetContainer = o2, t3.importOnlyMeshes = true, e4 === "" ? t3.importMeshesNames = [] : typeof e4 == "string" ? t3.importMeshesNames = [e4] : !e4 || e4 instanceof Array ? (t3.importMeshesNames = [], h.Tools.Warn("Argument meshesNames must be of type string or string[]")) : t3.importMeshesNames = [e4], l2._createNodes(t3);
              var n3 = new Array(), r3 = new Array();
              for (var s3 in t3.nodes) {
                var u2 = t3.nodes[s3];
                u2.babylonNode instanceof h.AbstractMesh && n3.push(u2.babylonNode);
              }
              for (var c2 in t3.skins) {
                var d2 = t3.skins[c2];
                d2.babylonSkeleton instanceof h.Skeleton && r3.push(d2.babylonSkeleton);
              }
              l2._loadBuffersAsync(t3, function() {
                l2._loadShadersAsync(t3, function() {
                  V(t3), I(t3), !_.GLTFFileLoader.IncrementalLoading && a2 && a2(n3, r3);
                });
              }, i2), _.GLTFFileLoader.IncrementalLoading && a2 && a2(n3, r3);
            }, s2), true;
          }, e3.prototype.importMeshAsync = function(e4, t2, n2, r2, o2, a2) {
            var i2 = this;
            return new Promise(function(s2, l2) {
              i2._importMeshAsync(e4, t2, r2, o2, n2, function(e5, t3) {
                s2({ meshes: e5, particleSystems: [], skeletons: t3, animationGroups: [], lights: [], transformNodes: [], geometries: [] });
              }, a2, function(e5) {
                l2(new Error(e5));
              });
            });
          }, e3.prototype._loadAsync = function(e4, t2, n2, r2, o2, a2, i2) {
            var s2 = this;
            e4.useRightHandedSystem = true, U.LoadRuntimeAsync(e4, t2, n2, function(e5) {
              U.LoadRuntimeExtensionsAsync(e5, function() {
                s2._createNodes(e5), s2._loadBuffersAsync(e5, function() {
                  s2._loadShadersAsync(e5, function() {
                    V(e5), I(e5), _.GLTFFileLoader.IncrementalLoading || o2();
                  });
                }), _.GLTFFileLoader.IncrementalLoading && o2();
              }, i2);
            }, i2);
          }, e3.prototype.loadAsync = function(e4, t2, n2, r2) {
            var o2 = this;
            return new Promise(function(a2, i2) {
              o2._loadAsync(e4, t2, n2, false, function() {
                a2();
              }, r2, function(e5) {
                i2(new Error(e5));
              });
            });
          }, e3.prototype._loadShadersAsync = function(e4, t2) {
            var n2 = false, r2 = function(n3, r3) {
              U.LoadShaderStringAsync(e4, n3, function(a3) {
                a3 instanceof ArrayBuffer || (e4.loadedShaderCount++, a3 && (h.Effect.ShadersStore[n3 + (r3.type === o.VERTEX ? "VertexShader" : "PixelShader")] = a3), e4.loadedShaderCount === e4.shaderscount && t2());
              }, function() {
                h.Tools.Error("Error when loading shader program named " + n3 + " located at " + r3.uri);
              });
            };
            for (var a2 in e4.shaders) {
              n2 = true;
              var i2 = e4.shaders[a2];
              i2 ? r2.bind(this, a2, i2)() : h.Tools.Error("No shader named: " + a2);
            }
            n2 || t2();
          }, e3.prototype._loadBuffersAsync = function(e4, t2, n2) {
            var r2 = false, o2 = function(n3, r3) {
              U.LoadBufferAsync(e4, n3, function(o3) {
                e4.loadedBufferCount++, o3 && (o3.byteLength != e4.buffers[n3].byteLength && h.Tools.Error("Buffer named " + n3 + " is length " + o3.byteLength + ". Expected: " + r3.byteLength), e4.loadedBufferViews[n3] = o3), e4.loadedBufferCount === e4.buffersCount && t2();
              }, function() {
                h.Tools.Error("Error when loading buffer named " + n3 + " located at " + r3.uri);
              });
            };
            for (var a2 in e4.buffers) {
              r2 = true;
              var i2 = e4.buffers[a2];
              i2 ? o2.bind(this, a2, i2)() : h.Tools.Error("No buffer named: " + a2);
            }
            r2 || t2();
          }, e3.prototype._createNodes = function(e4) {
            var t2 = e4.currentScene;
            if (t2)
              for (var n2 = 0; n2 < t2.nodes.length; n2++)
                P(e4, t2.nodes[n2], null);
            else
              for (var r2 in e4.scenes) {
                t2 = e4.scenes[r2];
                for (n2 = 0; n2 < t2.nodes.length; n2++)
                  P(e4, t2.nodes[n2], null);
              }
          }, e3.Extensions = {}, e3;
        }(), U = function() {
          function e3(e4) {
            this._name = e4;
          }
          return Object.defineProperty(e3.prototype, "name", { get: function() {
            return this._name;
          }, enumerable: false, configurable: true }), e3.prototype.loadRuntimeAsync = function(e4, t2, n2, r2, o2) {
            return false;
          }, e3.prototype.loadRuntimeExtensionsAsync = function(e4, t2, n2) {
            return false;
          }, e3.prototype.loadBufferAsync = function(e4, t2, n2, r2, o2) {
            return false;
          }, e3.prototype.loadTextureBufferAsync = function(e4, t2, n2, r2) {
            return false;
          }, e3.prototype.createTextureAsync = function(e4, t2, n2, r2, o2) {
            return false;
          }, e3.prototype.loadShaderStringAsync = function(e4, t2, n2, r2) {
            return false;
          }, e3.prototype.loadMaterialAsync = function(e4, t2, n2, r2) {
            return false;
          }, e3.LoadRuntimeAsync = function(t2, n2, r2, o2, a2) {
            e3.ApplyExtensions(function(e4) {
              return e4.loadRuntimeAsync(t2, n2, r2, o2, a2);
            }, function() {
              setTimeout(function() {
                o2 && o2(D.CreateRuntime(n2.json, t2, r2));
              });
            });
          }, e3.LoadRuntimeExtensionsAsync = function(t2, n2, r2) {
            e3.ApplyExtensions(function(e4) {
              return e4.loadRuntimeExtensionsAsync(t2, n2, r2);
            }, function() {
              setTimeout(function() {
                n2();
              });
            });
          }, e3.LoadBufferAsync = function(t2, n2, r2, o2, a2) {
            e3.ApplyExtensions(function(e4) {
              return e4.loadBufferAsync(t2, n2, r2, o2, a2);
            }, function() {
              D.LoadBufferAsync(t2, n2, r2, o2, a2);
            });
          }, e3.LoadTextureAsync = function(t2, n2, r2, o2) {
            e3.LoadTextureBufferAsync(t2, n2, function(a2) {
              a2 && e3.CreateTextureAsync(t2, n2, a2, r2, o2);
            }, o2);
          }, e3.LoadShaderStringAsync = function(t2, n2, r2, o2) {
            e3.ApplyExtensions(function(e4) {
              return e4.loadShaderStringAsync(t2, n2, r2, o2);
            }, function() {
              D.LoadShaderStringAsync(t2, n2, r2, o2);
            });
          }, e3.LoadMaterialAsync = function(t2, n2, r2, o2) {
            e3.ApplyExtensions(function(e4) {
              return e4.loadMaterialAsync(t2, n2, r2, o2);
            }, function() {
              D.LoadMaterialAsync(t2, n2, r2, o2);
            });
          }, e3.LoadTextureBufferAsync = function(t2, n2, r2, o2) {
            e3.ApplyExtensions(function(e4) {
              return e4.loadTextureBufferAsync(t2, n2, r2, o2);
            }, function() {
              D.LoadTextureBufferAsync(t2, n2, r2, o2);
            });
          }, e3.CreateTextureAsync = function(t2, n2, r2, o2, a2) {
            e3.ApplyExtensions(function(e4) {
              return e4.createTextureAsync(t2, n2, r2, o2, a2);
            }, function() {
              D.CreateTextureAsync(t2, n2, r2, o2, a2);
            });
          }, e3.ApplyExtensions = function(e4, t2) {
            for (var n2 in G.Extensions) {
              if (e4(G.Extensions[n2]))
                return;
            }
            t2();
          }, e3;
        }();
        _.GLTFFileLoader._CreateGLTF1Loader = function() {
          return new G();
        };
        var k = function(e3) {
          function t2() {
            return e3.call(this, "KHR_binary_glTF") || this;
          }
          return Object(d.b)(t2, e3), t2.prototype.loadRuntimeAsync = function(e4, t3, n2, r2, o2) {
            var a2 = t3.json.extensionsUsed;
            return !(!a2 || a2.indexOf(this.name) === -1 || !t3.bin) && (this._bin = t3.bin, r2(D.CreateRuntime(t3.json, e4, n2)), true);
          }, t2.prototype.loadBufferAsync = function(e4, t3, n2, r2) {
            return e4.extensionsUsed.indexOf(this.name) !== -1 && (t3 === "binary_glTF" && (this._bin.readAsync(0, this._bin.byteLength).then(n2, function(e5) {
              return r2(e5.message);
            }), true));
          }, t2.prototype.loadTextureBufferAsync = function(e4, t3, n2, o2) {
            var a2 = e4.textures[t3], i2 = e4.images[a2.source];
            if (!i2.extensions || !(this.name in i2.extensions))
              return false;
            var s2 = i2.extensions[this.name], l2 = e4.bufferViews[s2.bufferView];
            return n2(p.GetBufferFromBufferView(e4, l2, 0, l2.byteLength, r.UNSIGNED_BYTE)), true;
          }, t2.prototype.loadShaderStringAsync = function(e4, t3, n2, o2) {
            var a2 = e4.shaders[t3];
            if (!a2.extensions || !(this.name in a2.extensions))
              return false;
            var i2 = a2.extensions[this.name], s2 = e4.bufferViews[i2.bufferView], l2 = p.GetBufferFromBufferView(e4, s2, 0, s2.byteLength, r.UNSIGNED_BYTE);
            return setTimeout(function() {
              var e5 = p.DecodeBufferToText(l2);
              n2(e5);
            }), true;
          }, t2;
        }(U);
        G.RegisterExtension(new k());
        var H = function(e3) {
          function t2() {
            return e3.call(this, "KHR_materials_common") || this;
          }
          return Object(d.b)(t2, e3), t2.prototype.loadRuntimeExtensionsAsync = function(e4, t3, n2) {
            if (!e4.extensions)
              return false;
            var r2 = e4.extensions[this.name];
            if (!r2)
              return false;
            var o2 = r2.lights;
            if (o2)
              for (var a2 in o2) {
                var i2 = o2[a2];
                switch (i2.type) {
                  case "ambient":
                    var s2 = new h.HemisphericLight(i2.name, new h.Vector3(0, 1, 0), e4.scene), l2 = i2.ambient;
                    l2 && (s2.diffuse = h.Color3.FromArray(l2.color || [1, 1, 1]));
                    break;
                  case "point":
                    var u2 = new h.PointLight(i2.name, new h.Vector3(10, 10, 10), e4.scene), c2 = i2.point;
                    c2 && (u2.diffuse = h.Color3.FromArray(c2.color || [1, 1, 1]));
                    break;
                  case "directional":
                    var d2 = new h.DirectionalLight(i2.name, new h.Vector3(0, -1, 0), e4.scene), f2 = i2.directional;
                    f2 && (d2.diffuse = h.Color3.FromArray(f2.color || [1, 1, 1]));
                    break;
                  case "spot":
                    var p2 = i2.spot;
                    if (p2)
                      new h.SpotLight(i2.name, new h.Vector3(0, 10, 0), new h.Vector3(0, -1, 0), p2.fallOffAngle || Math.PI, p2.fallOffExponent || 0, e4.scene).diffuse = h.Color3.FromArray(p2.color || [1, 1, 1]);
                    break;
                  default:
                    h.Tools.Warn('GLTF Material Common extension: light type "' + i2.type + "\u201D not supported");
                }
              }
            return false;
          }, t2.prototype.loadMaterialAsync = function(e4, t3, n2, r2) {
            var o2 = e4.materials[t3];
            if (!o2 || !o2.extensions)
              return false;
            var a2 = o2.extensions[this.name];
            if (!a2)
              return false;
            var i2 = new h.StandardMaterial(t3, e4.scene);
            return i2.sideOrientation = h.Material.CounterClockWiseSideOrientation, a2.technique === "CONSTANT" && (i2.disableLighting = true), i2.backFaceCulling = a2.doubleSided !== void 0 && !a2.doubleSided, i2.alpha = a2.values.transparency === void 0 ? 1 : a2.values.transparency, i2.specularPower = a2.values.shininess === void 0 ? 0 : a2.values.shininess, typeof a2.values.ambient == "string" ? this._loadTexture(e4, a2.values.ambient, i2, "ambientTexture", r2) : i2.ambientColor = h.Color3.FromArray(a2.values.ambient || [0, 0, 0]), typeof a2.values.diffuse == "string" ? this._loadTexture(e4, a2.values.diffuse, i2, "diffuseTexture", r2) : i2.diffuseColor = h.Color3.FromArray(a2.values.diffuse || [0, 0, 0]), typeof a2.values.emission == "string" ? this._loadTexture(e4, a2.values.emission, i2, "emissiveTexture", r2) : i2.emissiveColor = h.Color3.FromArray(a2.values.emission || [0, 0, 0]), typeof a2.values.specular == "string" ? this._loadTexture(e4, a2.values.specular, i2, "specularTexture", r2) : i2.specularColor = h.Color3.FromArray(a2.values.specular || [0, 0, 0]), true;
          }, t2.prototype._loadTexture = function(e4, t3, n2, r2, o2) {
            D.LoadTextureBufferAsync(e4, t3, function(a2) {
              D.CreateTextureAsync(e4, t3, a2, function(e5) {
                return n2[r2] = e5;
              }, o2);
            }, o2);
          }, t2;
        }(U);
        G.RegisterExtension(new H());
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "ArrayItem", function() {
          return r.a;
        }), n.d(t, "GLTFLoader", function() {
          return r.b;
        }), n.d(t, "EXT_lights_image_based", function() {
          return o.EXT_lights_image_based;
        }), n.d(t, "EXT_mesh_gpu_instancing", function() {
          return o.EXT_mesh_gpu_instancing;
        }), n.d(t, "EXT_texture_webp", function() {
          return o.EXT_texture_webp;
        }), n.d(t, "KHR_draco_mesh_compression", function() {
          return o.KHR_draco_mesh_compression;
        }), n.d(t, "KHR_lights", function() {
          return o.KHR_lights;
        }), n.d(t, "KHR_materials_pbrSpecularGlossiness", function() {
          return o.KHR_materials_pbrSpecularGlossiness;
        }), n.d(t, "KHR_materials_unlit", function() {
          return o.KHR_materials_unlit;
        }), n.d(t, "KHR_materials_clearcoat", function() {
          return o.KHR_materials_clearcoat;
        }), n.d(t, "KHR_materials_sheen", function() {
          return o.KHR_materials_sheen;
        }), n.d(t, "KHR_materials_specular", function() {
          return o.KHR_materials_specular;
        }), n.d(t, "KHR_materials_ior", function() {
          return o.KHR_materials_ior;
        }), n.d(t, "KHR_materials_variants", function() {
          return o.KHR_materials_variants;
        }), n.d(t, "KHR_materials_transmission", function() {
          return o.KHR_materials_transmission;
        }), n.d(t, "KHR_materials_translucency", function() {
          return o.KHR_materials_translucency;
        }), n.d(t, "KHR_mesh_quantization", function() {
          return o.KHR_mesh_quantization;
        }), n.d(t, "KHR_texture_basisu", function() {
          return o.KHR_texture_basisu;
        }), n.d(t, "KHR_texture_transform", function() {
          return o.KHR_texture_transform;
        }), n.d(t, "MSFT_audio_emitter", function() {
          return o.MSFT_audio_emitter;
        }), n.d(t, "MSFT_lod", function() {
          return o.MSFT_lod;
        }), n.d(t, "MSFT_minecraftMesh", function() {
          return o.MSFT_minecraftMesh;
        }), n.d(t, "MSFT_sRGBFactors", function() {
          return o.MSFT_sRGBFactors;
        }), n.d(t, "ExtrasAsMetadata", function() {
          return o.ExtrasAsMetadata;
        });
        var r = n(1), o = (n(6), n(7));
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "MTLFileLoader", function() {
          return o;
        }), n.d(t, "OBJFileLoader", function() {
          return a;
        });
        var r = n(0), o = function() {
          function e3() {
            this.materials = [];
          }
          return e3.prototype.parseMTL = function(t2, n2, o2, a2) {
            if (!(n2 instanceof ArrayBuffer)) {
              for (var i, s = n2.split("\n"), l = /\s+/, u = null, c = 0; c < s.length; c++) {
                var d = s[c].trim();
                if (d.length !== 0 && d.charAt(0) !== "#") {
                  var f = d.indexOf(" "), h = f >= 0 ? d.substring(0, f) : d;
                  h = h.toLowerCase();
                  var p = f >= 0 ? d.substring(f + 1).trim() : "";
                  h === "newmtl" ? (u && this.materials.push(u), t2._blockEntityCollection = a2, u = new r.StandardMaterial(p, t2), t2._blockEntityCollection = false) : h === "kd" && u ? (i = p.split(l, 3).map(parseFloat), u.diffuseColor = r.Color3.FromArray(i)) : h === "ka" && u ? (i = p.split(l, 3).map(parseFloat), u.ambientColor = r.Color3.FromArray(i)) : h === "ks" && u ? (i = p.split(l, 3).map(parseFloat), u.specularColor = r.Color3.FromArray(i)) : h === "ke" && u ? (i = p.split(l, 3).map(parseFloat), u.emissiveColor = r.Color3.FromArray(i)) : h === "ns" && u ? u.specularPower = parseFloat(p) : h === "d" && u ? u.alpha = parseFloat(p) : h === "map_ka" && u ? u.ambientTexture = e3._getTexture(o2, p, t2) : h === "map_kd" && u ? u.diffuseTexture = e3._getTexture(o2, p, t2) : h === "map_ks" && u ? u.specularTexture = e3._getTexture(o2, p, t2) : h === "map_ns" || (h === "map_bump" && u ? u.bumpTexture = e3._getTexture(o2, p, t2) : h === "map_d" && u && (u.opacityTexture = e3._getTexture(o2, p, t2)));
                }
              }
              u && this.materials.push(u);
            }
          }, e3._getTexture = function(t2, n2, o2) {
            if (!n2)
              return null;
            var a2 = t2;
            if (t2 === "file:") {
              var i = n2.lastIndexOf("\\");
              i === -1 && (i = n2.lastIndexOf("/")), a2 += i > -1 ? n2.substr(i + 1) : n2;
            } else
              a2 += n2;
            return new r.Texture(a2, o2, false, e3.INVERT_TEXTURE_Y);
          }, e3.INVERT_TEXTURE_Y = true, e3;
        }(), a = function() {
          function e3(t2) {
            this.name = "obj", this.extensions = ".obj", this.obj = /^o/, this.group = /^g/, this.mtllib = /^mtllib /, this.usemtl = /^usemtl /, this.smooth = /^s /, this.vertexPattern = /v(\s+[\d|\.|\+|\-|e|E]+){3,7}/, this.normalPattern = /vn(\s+[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/, this.uvPattern = /vt(\s+[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/, this.facePattern1 = /f\s+(([\d]{1,}[\s]?){3,})+/, this.facePattern2 = /f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/, this.facePattern3 = /f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/, this.facePattern4 = /f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/, this.facePattern5 = /f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/, this._forAssetContainer = false, this._meshLoadOptions = t2 || e3.currentMeshLoadOptions;
          }
          return Object.defineProperty(e3, "INVERT_TEXTURE_Y", { get: function() {
            return o.INVERT_TEXTURE_Y;
          }, set: function(e4) {
            o.INVERT_TEXTURE_Y = e4;
          }, enumerable: false, configurable: true }), Object.defineProperty(e3, "currentMeshLoadOptions", { get: function() {
            return { ComputeNormals: e3.COMPUTE_NORMALS, ImportVertexColors: e3.IMPORT_VERTEX_COLORS, InvertY: e3.INVERT_Y, InvertTextureY: e3.INVERT_TEXTURE_Y, UVScaling: e3.UV_SCALING, MaterialLoadingFailsSilently: e3.MATERIAL_LOADING_FAILS_SILENTLY, OptimizeWithUV: e3.OPTIMIZE_WITH_UV, SkipMaterials: e3.SKIP_MATERIALS };
          }, enumerable: false, configurable: true }), e3.prototype._loadMTL = function(e4, t2, n2, o2) {
            var a2 = r.Tools.BaseUrl + t2 + e4;
            r.Tools.LoadFile(a2, n2, void 0, void 0, false, function(e5, t3) {
              o2(a2, t3);
            });
          }, e3.prototype.createPlugin = function() {
            return new e3(e3.currentMeshLoadOptions);
          }, e3.prototype.canDirectLoad = function(e4) {
            return false;
          }, e3.prototype.importMeshAsync = function(e4, t2, n2, r2, o2, a2) {
            return this._parseSolid(e4, t2, n2, r2).then(function(e5) {
              return { meshes: e5, particleSystems: [], skeletons: [], animationGroups: [], transformNodes: [], geometries: [], lights: [] };
            });
          }, e3.prototype.loadAsync = function(e4, t2, n2, r2, o2) {
            return this.importMeshAsync(null, e4, t2, n2, r2).then(function() {
            });
          }, e3.prototype.loadAssetContainerAsync = function(e4, t2, n2, o2, a2) {
            var i = this;
            return this._forAssetContainer = true, this.importMeshAsync(null, e4, t2, n2).then(function(t3) {
              var n3 = new r.AssetContainer(e4);
              return t3.meshes.forEach(function(e5) {
                return n3.meshes.push(e5);
              }), t3.meshes.forEach(function(e5) {
                var t4 = e5.material;
                t4 && (n3.materials.indexOf(t4) == -1 && (n3.materials.push(t4), t4.getActiveTextures().forEach(function(e6) {
                  n3.textures.indexOf(e6) == -1 && n3.textures.push(e6);
                })));
              }), i._forAssetContainer = false, n3;
            }).catch(function(e5) {
              throw i._forAssetContainer = false, e5;
            });
          }, e3.prototype._parseSolid = function(t2, n2, a2, i) {
            for (var s, l = this, u = [], c = [], d = [], f = [], h = [], p = [], _ = [], m = [], y = [], b = [], v = [], g = 0, A = false, T = [], x = [], E = [], L = [], O = [], M = "", S = "", w = new o(), R = 1, C = true, N = new r.Color4(0.5, 0.5, 0.5, 1), P = function(e4, t3, n3, r2, o2, a3, i2) {
              var s2;
              (s2 = l._meshLoadOptions.OptimizeWithUV ? function(e5, t4) {
                e5[t4[0]] || (e5[t4[0]] = { normals: [], idx: [], uv: [] });
                var n4 = e5[t4[0]].normals.indexOf(t4[1]);
                return n4 != 1 && t4[2] === e5[t4[0]].uv[n4] ? e5[t4[0]].idx[n4] : -1;
              }(v, [e4, n3, t3]) : function(e5, t4) {
                e5[t4[0]] || (e5[t4[0]] = { normals: [], idx: [] });
                var n4 = e5[t4[0]].normals.indexOf(t4[1]);
                return n4 === -1 ? -1 : e5[t4[0]].idx[n4];
              }(v, [e4, n3])) === -1 ? (p.push(_.length), _.push(r2), m.push(o2), b.push(a3), i2 !== void 0 && y.push(i2), v[e4].normals.push(n3), v[e4].idx.push(g++), l._meshLoadOptions.OptimizeWithUV && v[e4].uv.push(t3)) : p.push(s2);
            }, I = function() {
              for (var e4 = 0; e4 < _.length; e4++)
                T.push(_[e4].x, _[e4].y, _[e4].z), E.push(b[e4].x, b[e4].y, b[e4].z), L.push(m[e4].x, m[e4].y), l._meshLoadOptions.ImportVertexColors === true && x.push(y[e4].r, y[e4].g, y[e4].b, y[e4].a);
              _ = [], b = [], m = [], y = [], v = [], g = 0;
            }, F = function(e4, t3) {
              for (var n3 = t3; n3 < e4.length - 1; n3++)
                O.push(e4[0], e4[n3], e4[n3 + 1]);
            }, B = function(e4, t3) {
              F(e4, t3);
              for (var n3 = 0; n3 < O.length; n3++) {
                var o2 = parseInt(O[n3]) - 1;
                P(o2, 0, 0, u[o2], r.Vector2.Zero(), r.Vector3.Up(), l._meshLoadOptions.ImportVertexColors === true ? f[o2] : void 0);
              }
              O = [];
            }, V = function(e4, t3) {
              F(e4, t3);
              for (var n3 = 0; n3 < O.length; n3++) {
                var o2 = O[n3].split("/"), a3 = parseInt(o2[0]) - 1, i2 = parseInt(o2[1]) - 1;
                P(a3, i2, 0, u[a3], d[i2], r.Vector3.Up(), l._meshLoadOptions.ImportVertexColors === true ? f[a3] : void 0);
              }
              O = [];
            }, D = function(e4, t3) {
              F(e4, t3);
              for (var n3 = 0; n3 < O.length; n3++) {
                var r2 = O[n3].split("/"), o2 = parseInt(r2[0]) - 1, a3 = parseInt(r2[1]) - 1, i2 = parseInt(r2[2]) - 1;
                P(o2, a3, i2, u[o2], d[a3], c[i2]);
              }
              O = [];
            }, G = function(e4, t3) {
              F(e4, t3);
              for (var n3 = 0; n3 < O.length; n3++) {
                var o2 = O[n3].split("//"), a3 = parseInt(o2[0]) - 1, i2 = parseInt(o2[1]) - 1;
                P(a3, 1, i2, u[a3], r.Vector2.Zero(), c[i2], l._meshLoadOptions.ImportVertexColors === true ? f[a3] : void 0);
              }
              O = [];
            }, U = function(e4, t3) {
              F(e4, t3);
              for (var n3 = 0; n3 < O.length; n3++) {
                var r2 = O[n3].split("/"), o2 = u.length + parseInt(r2[0]), a3 = d.length + parseInt(r2[1]), i2 = c.length + parseInt(r2[2]);
                P(o2, a3, i2, u[o2], d[a3], c[i2], l._meshLoadOptions.ImportVertexColors === true ? f[o2] : void 0);
              }
              O = [];
            }, k = function() {
              h.length > 0 && (s = h[h.length - 1], I(), p.reverse(), s.indices = p.slice(), s.positions = T.slice(), s.normals = E.slice(), s.uvs = L.slice(), l._meshLoadOptions.ImportVertexColors === true && (s.colors = x.slice()), p = [], T = [], x = [], E = [], L = []);
            }, H = a2.split("\n"), K = 0; K < H.length; K++) {
              var j, W = H[K].trim().replace(/\s\s/g, " ");
              if (W.length !== 0 && W.charAt(0) !== "#")
                if (this.vertexPattern.test(W))
                  j = W.match(/[^ ]+/g), u.push(new r.Vector3(parseFloat(j[1]), parseFloat(j[2]), parseFloat(j[3]))), this._meshLoadOptions.ImportVertexColors === true && (j.length >= 7 ? f.push(new r.Color4(parseFloat(j[4]), parseFloat(j[5]), parseFloat(j[6]), j.length === 7 || j[7] === void 0 ? 1 : parseFloat(j[7]))) : f.push(N));
                else if ((j = this.normalPattern.exec(W)) !== null)
                  c.push(new r.Vector3(parseFloat(j[1]), parseFloat(j[2]), parseFloat(j[3])));
                else if ((j = this.uvPattern.exec(W)) !== null)
                  d.push(new r.Vector2(parseFloat(j[1]) * e3.UV_SCALING.x, parseFloat(j[2]) * e3.UV_SCALING.y));
                else if ((j = this.facePattern3.exec(W)) !== null)
                  D(j[1].trim().split(" "), 1);
                else if ((j = this.facePattern4.exec(W)) !== null)
                  G(j[1].trim().split(" "), 1);
                else if ((j = this.facePattern5.exec(W)) !== null)
                  U(j[1].trim().split(" "), 1);
                else if ((j = this.facePattern2.exec(W)) !== null)
                  V(j[1].trim().split(" "), 1);
                else if ((j = this.facePattern1.exec(W)) !== null)
                  B(j[1].trim().split(" "), 1);
                else if (this.group.test(W) || this.obj.test(W)) {
                  var q = { name: W.substring(2).trim(), indices: void 0, positions: void 0, normals: void 0, uvs: void 0, colors: void 0, materialName: "" };
                  k(), h.push(q), A = true, C = true, R = 1;
                } else if (this.usemtl.test(W)) {
                  if (M = W.substring(7).trim(), !C || !A) {
                    k();
                    q = { name: "mesh_mm" + R.toString(), indices: void 0, positions: void 0, normals: void 0, uvs: void 0, colors: void 0, materialName: M };
                    R++, h.push(q), A = true;
                  }
                  A && C && (h[h.length - 1].materialName = M, C = false);
                } else
                  this.mtllib.test(W) ? S = W.substring(7).trim() : this.smooth.test(W) || console.log("Unhandled expression at line : " + W);
            }
            A && (s = h[h.length - 1], p.reverse(), I(), s.indices = p, s.positions = T, s.normals = E, s.uvs = L, this._meshLoadOptions.ImportVertexColors === true && (s.colors = x)), A || (p.reverse(), I(), h.push({ name: r.Geometry.RandomId(), indices: p, positions: T, colors: x, normals: E, uvs: L, materialName: M }));
            for (var Y = [], X = new Array(), J = 0; J < h.length; J++) {
              if (t2 && h[J].name) {
                if (t2 instanceof Array) {
                  if (t2.indexOf(h[J].name) === -1)
                    continue;
                } else if (h[J].name !== t2)
                  continue;
              }
              s = h[J], n2._blockEntityCollection = this._forAssetContainer;
              var Q = new r.Mesh(h[J].name, n2);
              n2._blockEntityCollection = false, X.push(h[J].materialName);
              var z = new r.VertexData();
              if (z.uvs = s.uvs, z.indices = s.indices, z.positions = s.positions, this._meshLoadOptions.ComputeNormals === true) {
                var Z = new Array();
                r.VertexData.ComputeNormals(s.positions, s.indices, Z), z.normals = Z;
              } else
                z.normals = s.normals;
              this._meshLoadOptions.ImportVertexColors === true && (z.colors = s.colors), z.applyToMesh(Q), this._meshLoadOptions.InvertY && (Q.scaling.y *= -1), Y.push(Q);
            }
            var $ = [];
            return S !== "" && this._meshLoadOptions.SkipMaterials === false && $.push(new Promise(function(e4, t3) {
              l._loadMTL(S, i, function(o2) {
                try {
                  w.parseMTL(n2, o2, i, l._forAssetContainer);
                  for (var a3 = 0; a3 < w.materials.length; a3++) {
                    for (var s2, u2 = 0, c2 = []; (s2 = X.indexOf(w.materials[a3].name, u2)) > -1; )
                      c2.push(s2), u2 = s2 + 1;
                    if (s2 === -1 && c2.length === 0)
                      w.materials[a3].dispose();
                    else
                      for (var d2 = 0; d2 < c2.length; d2++)
                        Y[c2[d2]].material = w.materials[a3];
                  }
                  e4();
                } catch (n3) {
                  r.Tools.Warn("Error processing MTL file: '" + S + "'"), l._meshLoadOptions.MaterialLoadingFailsSilently ? e4() : t3(n3);
                }
              }, function(n3, o2) {
                r.Tools.Warn("Error downloading MTL file: '" + S + "'"), l._meshLoadOptions.MaterialLoadingFailsSilently ? e4() : t3(o2);
              });
            })), Promise.all($).then(function() {
              return Y;
            });
          }, e3.OPTIMIZE_WITH_UV = true, e3.INVERT_Y = false, e3.IMPORT_VERTEX_COLORS = false, e3.COMPUTE_NORMALS = false, e3.UV_SCALING = new r.Vector2(1, 1), e3.SKIP_MATERIALS = false, e3.MATERIAL_LOADING_FAILS_SILENTLY = true, e3;
        }();
        r.SceneLoader && r.SceneLoader.RegisterPlugin(new a());
      }, function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "STLFileLoader", function() {
          return o;
        });
        var r = n(0), o = function() {
          function e3() {
            this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g, this.facetsPattern = /facet([\s\S]*?)endfacet/g, this.normalPattern = /normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g, this.vertexPattern = /vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g, this.name = "stl", this.extensions = { ".stl": { isBinary: true } };
          }
          return e3.prototype.importMesh = function(e4, t2, n2, o2, a, i, s) {
            var l;
            if (typeof n2 != "string") {
              if (this._isBinary(n2)) {
                var u = new r.Mesh("stlmesh", t2);
                return this._parseBinary(u, n2), a && a.push(u), true;
              }
              for (var c = new Uint8Array(n2), d = "", f = 0; f < n2.byteLength; f++)
                d += String.fromCharCode(c[f]);
              n2 = d;
            }
            for (; l = this.solidPattern.exec(n2); ) {
              var h = l[1];
              if (h != l[3])
                return r.Tools.Error("Error in STL, solid name != endsolid name"), false;
              if (e4 && h) {
                if (e4 instanceof Array) {
                  if (!e4.indexOf(h))
                    continue;
                } else if (h !== e4)
                  continue;
              }
              h = h || "stlmesh";
              u = new r.Mesh(h, t2);
              this._parseASCII(u, l[2]), a && a.push(u);
            }
            return true;
          }, e3.prototype.load = function(e4, t2, n2) {
            return this.importMesh(null, e4, t2, n2, null, null, null);
          }, e3.prototype.loadAssetContainer = function(e4, t2, n2, o2) {
            var a = new r.AssetContainer(e4);
            return e4._blockEntityCollection = true, this.importMesh(null, e4, t2, n2, a.meshes, null, null), e4._blockEntityCollection = false, a;
          }, e3.prototype._isBinary = function(e4) {
            var t2;
            if (50, 84 + 50 * (t2 = new DataView(e4)).getUint32(80, true) === t2.byteLength)
              return true;
            for (var n2 = t2.byteLength, r2 = 0; r2 < n2; r2++)
              if (t2.getUint8(r2) > 127)
                return true;
            return false;
          }, e3.prototype._parseBinary = function(e4, t2) {
            for (var n2 = new DataView(t2), o2 = n2.getUint32(80, true), a = 0, i = new Float32Array(3 * o2 * 3), s = new Float32Array(3 * o2 * 3), l = new Uint32Array(3 * o2), u = 0, c = 0; c < o2; c++) {
              for (var d = 84 + 50 * c, f = n2.getFloat32(d, true), h = n2.getFloat32(d + 4, true), p = n2.getFloat32(d + 8, true), _ = 1; _ <= 3; _++) {
                var m = d + 12 * _;
                i[a] = n2.getFloat32(m, true), i[a + 2] = n2.getFloat32(m + 4, true), i[a + 1] = n2.getFloat32(m + 8, true), s[a] = f, s[a + 2] = h, s[a + 1] = p, a += 3;
              }
              l[u] = u++, l[u] = u++, l[u] = u++;
            }
            e4.setVerticesData(r.VertexBuffer.PositionKind, i), e4.setVerticesData(r.VertexBuffer.NormalKind, s), e4.setIndices(l), e4.computeWorldMatrix(true);
          }, e3.prototype._parseASCII = function(e4, t2) {
            for (var n2, o2 = [], a = [], i = [], s = 0; n2 = this.facetsPattern.exec(t2); ) {
              var l = n2[1], u = this.normalPattern.exec(l);
              if (this.normalPattern.lastIndex = 0, u) {
                for (var c, d = [Number(u[1]), Number(u[5]), Number(u[3])]; c = this.vertexPattern.exec(l); )
                  o2.push(Number(c[1]), Number(c[5]), Number(c[3])), a.push(d[0], d[1], d[2]);
                i.push(s++, s++, s++), this.vertexPattern.lastIndex = 0;
              }
            }
            this.facetsPattern.lastIndex = 0, e4.setVerticesData(r.VertexBuffer.PositionKind, o2), e4.setVerticesData(r.VertexBuffer.NormalKind, a), e4.setIndices(i), e4.computeWorldMatrix(true);
          }, e3;
        }();
        r.SceneLoader && r.SceneLoader.RegisterPlugin(new o());
      }, function(e2, t, n) {
        "use strict";
        (function(e3) {
          var r = n(2), o = n(3);
          n.d(t, "a", function() {
            return r.GLTFFileLoader;
          }), n.d(t, "b", function() {
            return r.GLTFLoaderAnimationStartMode;
          }), n.d(t, "c", function() {
            return r.GLTFLoaderCoordinateSystemMode;
          }), n.d(t, "d", function() {
            return r.GLTFLoaderState;
          }), n.d(t, "e", function() {
            return o.GLTFValidation;
          });
          var a = e3 !== void 0 ? e3 : typeof window != "undefined" ? window : void 0;
          if (a !== void 0) {
            for (var i in a.BABYLON = a.BABYLON || {}, r)
              a.BABYLON[i] = r[i];
            for (var i in o)
              a.BABYLON[i] = o[i];
          }
        }).call(this, n(5));
      }, function(e2, t, n) {
        "use strict";
        (function(e3) {
          var r = n(8);
          n.d(t, "a", function() {
            return r;
          });
          var o = e3 !== void 0 ? e3 : typeof window != "undefined" ? window : void 0;
          if (o !== void 0)
            for (var a in o.BABYLON = o.BABYLON || {}, o.BABYLON.GLTF1 = o.BABYLON.GLTF1 || {}, r)
              o.BABYLON.GLTF1[a] = r[a];
        }).call(this, n(5));
      }, function(e2, t, n) {
        "use strict";
        (function(e3) {
          var r = n(7), o = n(6), a = n(9);
          n.d(t, "a", function() {
            return a;
          });
          var i = e3 !== void 0 ? e3 : typeof window != "undefined" ? window : void 0;
          if (i !== void 0) {
            i.BABYLON = i.BABYLON || {};
            var s = i.BABYLON;
            s.GLTF2 = s.GLTF2 || {}, s.GLTF2.Loader = s.GLTF2.Loader || {}, s.GLTF2.Loader.Extensions = s.GLTF2.Loader.Extensions || {};
            var l = [];
            for (var u in r)
              s.GLTF2.Loader.Extensions[u] = r[u], l.push(u);
            for (var u in o)
              s.GLTF2.Loader[u] = o[u], l.push(u);
            for (var u in a)
              l.indexOf(u) > -1 || (s.GLTF2[u] = a[u]);
          }
        }).call(this, n(5));
      }, function(e2, t, n) {
        "use strict";
        n.r(t), function(e3) {
          var r = n(10);
          n.d(t, "MTLFileLoader", function() {
            return r.MTLFileLoader;
          }), n.d(t, "OBJFileLoader", function() {
            return r.OBJFileLoader;
          });
          var o = e3 !== void 0 ? e3 : typeof window != "undefined" ? window : void 0;
          if (o !== void 0)
            for (var a in r)
              o.BABYLON[a] = r[a];
        }.call(this, n(5));
      }, function(e2, t, n) {
        "use strict";
        n.r(t), function(e3) {
          var r = n(11);
          n.d(t, "STLFileLoader", function() {
            return r.STLFileLoader;
          });
          var o = e3 !== void 0 ? e3 : typeof window != "undefined" ? window : void 0;
          if (o !== void 0)
            for (var a in r)
              o.BABYLON[a] = r[a];
        }.call(this, n(5));
      }, , , , function(e2, t, n) {
        "use strict";
        n.r(t), n.d(t, "GLTFLoaderCoordinateSystemMode", function() {
          return r.c;
        }), n.d(t, "GLTFLoaderAnimationStartMode", function() {
          return r.b;
        }), n.d(t, "GLTFLoaderState", function() {
          return r.d;
        }), n.d(t, "GLTFFileLoader", function() {
          return r.a;
        }), n.d(t, "GLTFValidation", function() {
          return r.e;
        }), n.d(t, "GLTF1", function() {
          return o.a;
        }), n.d(t, "GLTF2", function() {
          return a.a;
        }), n.d(t, "MTLFileLoader", function() {
          return i.MTLFileLoader;
        }), n.d(t, "OBJFileLoader", function() {
          return i.OBJFileLoader;
        }), n.d(t, "STLFileLoader", function() {
          return s.STLFileLoader;
        });
        n(2), n(3), n(8), n(9), n(10), n(11);
        var r = n(12), o = n(13), a = n(14), i = n(15), s = n(16);
      }]);
    });
  }
});

// dep:babylonjs-loaders
var babylonjs_loaders_default = require_babylonjs_loaders_min();
export {
  babylonjs_loaders_default as default
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=babylonjs-loaders.js.map
